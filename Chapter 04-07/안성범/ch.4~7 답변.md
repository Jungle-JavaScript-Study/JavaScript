## Ch 4~7

Q1. `var`, `let`, `const의` 차이가 무엇인가?

- 내 대답
    - var 는 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다는 점.
    let 과 const 는 블록 레벨 스코프를 지원한다.
- 정답
    - `var`: 함수 스코프를 가짐, 재선언&재할당 가능, 호이스팅에 영향을 받음
    - `let`: 블록 스코프를 가짐, 재선언 불가, 재할당 가능
    - `const` : 블록 스코프를 가짐, 반드시 선언과 동시에 초기화를 해야 함, 재선언&재할당 불가능
- 꼬리질문
    - Q1-1. 호이스팅에 관해 설명하시오
        - 내 답
            - 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것
        - 정답
            
            > "인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것" —— by [mdn](https://developer.mozilla.org/ko/docs/Glossary/Hoisting).
            > 
            - JavaScript가 컴파일 과정에서 모든 스코프를 탐색하며 변수에 대한 선언과 초기화를 분리하여 선언에 대한 메모리부터 할당하는 것 (선언만 코드의 최상단으로 옮기는 것과 비슷한 효과)
            - 호이스팅의 대상은 선언만, 초기화는 호이스팅되지 않음.
            - 호이스팅 시 `var`는 `undefined`로 초기화, `let`/`const`는 초기화하지 않음
                - 따라서 var과 함수는 선언 전 사용 가능, `let`/`const`/`class`는 불가능
                - `let`/`const`에서 호이스팅된 부분과 실제 선언부 사이에서, 변수가 존재는 하지만 초기화되지 않은 부분을 TDZ(Temporal Dead Zone) 라고 함(이 때 변수 사용하면 `ReferenceError` 발생)
                - `var`만 호이스팅의 대상인 것처럼 보일 수 있으나 `let`/`const`도 호이스팅 대상임
    - Q1-2. `var`를 사용함으로써 일어날 수 있는 문제에 대해 설명하시오
        - 정답
            - 함수 스코프를 가지고 있기 때문에 의도치 않은 전역적 동작이 발생할 수 있다(스코프 관리가 어렵다)
            - 호이스팅으로 인해 변수 선언이 스코프 상단으로 옮겨지기 때문에 의도치 않은 동작이 발생할 수 있다
            - 재선언과 재할당이 가능하기 때문에 개발자가 의도하지 않은 변수의 재할당이 발생할 수 있다
        - 내 답
            
            의도치 않게 전역 변수가 선언되어 부작용이 발생할 수 있다.
            

Q2. 할당, 선언, 초기화, 참조에 대해 순서와 실행 시점을 포함하여 설명하시오

- 내 대답
    
    선언 : var 키워드로 선언하면, 런타임 이전 호이스팅되어 실행됨.
    
    초기화 : var 키워드로 선언하면 런타임 이전에 선언과 동시에 undefined로 초기화 됨.
    
    할당 : 런타임시점에 소스코드 한줄씩 평가단계를 거치며 실행됨.
    
    참조 : 소스코드 상에서 참조 될 때, 메모리에 주소값을 참조하게 됨. 런타임 시점.
    
- 정답
    - 선언: 메모리 공간을 할당받고 변수 이름과 메모리 주소를 연결하는 것, 자바스크립트 엔진이 런타임 이전에 소스코드를 평가할 때 실행됨(=호이스팅)
    - 초기화(정의): 값을 저장할 메모리 공간을 할당받고 암묵적으로 `undefined`를 할당하는 것, 자바스크립트에서는 변수를 선언할 때 선언 단계화 초기화 단계가 같이 일어남
        - 정확히는 자바스크립트에서 변수의 선언 = 선언 단계(변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알리는 것) + 초기화 단계, 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이루어지기 때문에 구분이 모호함
    - 할당: 만들어진 변수에 값을 대입하는 것, 런타임에 실행됨
    - 참조: 런타임에 코드가 한 줄씩 실행되면서 변수나 함수에 접근하는 것, 런타임 시점
- 꼬리 질문
    
    Q2-1. 변수에 값을 재할당할 때 일어나는 일을 설명하시오
    
    - 정답
        
        새로운 메모리 공간을 할당받고 변수가 참조하던 메모리 주소값을 업데이트한다. 이전 메모리 주소에 있던 값은 참조하는 변수가 없으면 가비지콜렉터에 의해 메모리에서 해제된다.
        
        ※var로 선언한 변수는 선언과 동시에 초기화되기 때문에 처음 할당하는 것도 사실 재할당이다
        
    - 내 답
        - 재할당은 변수에 저장된 값을 다른 값으로 변경한다.
        - **새로운 메모리 공간을 확보**하고 할당**값을 저장한다.**

Q3. 자바스크립트에서의 최소 단위를 `statement`와 `token`의 관점에서 설명하시오

- 정답
    - `statement`: 자바스크립트에서 실행 가능한 최소 코드 단위. 보통 세미콜론(;)으로 끝나고 실행될 때 어떤 작업을 수행함 ex. 변수 선언, 할당, 조건문, 반복문
    - `token`: 소스 코드에서 의미를 가지는 최소 단위. 자바스크립트 엔진은 코드를 분석할 때 토큰 단위로 분리하고, 이를 기반으로 파싱하여 문법적인 구조를 이해함 ex. 키워드, 식별자, 연산자
- 내 대답
    
    문은 **프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.**
    
    문은 여러 토큰으로 구성된다. ****************************************************************************************************************************************************************************************************************************************************************************************************토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 나타낸다.****************************************************************************************************************************************************************************************************************************************************************************************************
    

Q4. `undefined`와 `null`에 대해 설명하시오****

- 정답
    - `undefined`: 타입이자 값. 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값으로, 개발자가 할당하는 것은 지양
    - `null`: 타입이자 값. 변수에 값이 없다는 것을 의도적으로 명시할 때(이전에 참조하던 값을 더 이상 참조하지 않겠다는 뜻 -> 가비지콜렉션에 영향)나 함수가 유효한 값을 반환할 수 없는 경우 반환됨
- 내 대답
    - undefined : 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환
    - null : 프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재, intentional absence)할 때 사용한다.
    함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null 을 반환하기도 한다.

Q5. 데이터에 타입이 필요한 이유는 무엇인가?

- 정답
    - 값을 저장할 때 할당받을 메모리 공간의 크기 결정
    - 값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기 판단
    - 메모리에서 읽은 2진수를 어떻게 해석할지 결정
- 내 대답
    1. 값을 **저장**할 때 확보해야 하는 ******************************************메모리 공간의 크기******************************************를 결정하기 위해
    2. 값을 **참조**할 때 한 번에 읽어 들여야 할 ******************************************메모리 공간의 크기******************************************를 결정하기 위해
    3. 메모리에서 읽어 들인 ******************************************************2진수를 어떻게 해석******************************************************할지 결정하기 위해

Q7. c언어와 자바스크립트에서의 데이터 타입에서의 차이점을 설명하시오

- 정답
    - C언어: 정적 타입 언어로, 명시적 타입 선언(변수 선언할 때 타입 함께 선언) 필요. 변수의 타입은 컴파일 시간에 타입 체크가 발생하면서 결정되고 실행 시간에는 변경되지 않음
    - 자바스크립트: 동적 타입 언어. 값을 할당하는 시점에 타입이 동적으로 결정되고 실행 중에 변수의 타입을 동적으로 변경할 수 있음. 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론이 발생.
- 내 대답
    
    c 언어는 정적타입 언어로, 변수를 선언할 때, 타입을 정해서 선언해야 한다.
    
    자바스크립트는 동적 타입 언어로, 변수를 선언할 때 타입을 따로 정하지 않고 선언한다. - var, let, const 키워드로 선언 → 데이터 타입이 동적으로 변할 수 있다.
    
- 꼬리 질문
    
    Q7-1. 자바스크립트의 동적 타입 언어로서의 단점을 이야기하시오.
    
    - 정답
        - 값을 확인하기 전에는 타입을 확신할 수 없음
        - 개발자의 의도랑 상관없이 암묵적으로 타입이 변환될 수 있어 코드가 잘못 동작할 수 있음 -> 신뢰성이 설어짐
        - 실행 시간에 타입이 결정되기 때문에 코드의 복잡성이 증가할 수 있음
    - 내 대답
        
        개발자의 의도와 자바스크립트 엔진이 변환시키는 타입이 다를 때 의도치 않은 문제가 생길 수 있다.
        

Q8. 자바스크립트에서 2진수, 8진수, 10진수, 실수, 정수 변수를 표현하는 방법을 설명하시오.

- 정답
    
    자바스크립트에서 모든 숫자는 64비트 부동소수점 형식으로 표현됨
    
    - 2진수: `0b1010`
    - 8진수: `0o10`
    - 10진수(정수): `42`
    - 실수: `3.14`
- 내 대답
    
    자바스크립트는 배정밀도 64비트 부동소수점 형식을 따르므로, 실수와 정수는 따로 표현하지 않고, 모두 실수로 표현된다.
    
    2진수는 0b로,
    8진수는 0o로,
    16진수는 0x로 표현한다.
    

Q9. 암묵적 타입 변환에 대해 설명하시오

- 정답
    
    타입 강제 변환이라고도 함. 개발자의 의도와 관계없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것.
    
- 내 대답
    
    비교연산자를 사용할 때, 동일 비교 연산자(==) 는 좌항과 우항의 타입을 암묵적 타입변환을 시켜서 타입을 일치시킨 후 비교한다.
    
- 꼬리 질문
    
    Q9-1. 암묵적 타입 변환이 일어나는 예시를 2가지 설명하시오.
    
    - 정답
        1. `!`이나 삼항 연산자 조건식은 불리언으로 변환해서 연산
        2. 숫자 타입이 아닌 값에 `+` 연산하면 숫자로 변환해서 연산 수행
        3. 문자열과 숫자에 대해 `+` 연산하면 문자열로 변환해서 연산
        4. 비교연산자는 비교할 때 피연산자의 타입을 일치시키기 위해 암묵적 타입 변환
    - 내 대답
        1. 비교연산자를 사용할 때
        2. 변수가 선언되었을 때

Q10. 다음의 연산 결과와 그 이유에 대해 설명하시오

```jsx
1 + true;         //1
+null;            //2
NaN === NaN;      //3
0 === -0;          //4
Object.is(0, -0); //5
typeof null;      //6
typeof NaN;       //7
typeof foo;       //8
```

- 정답
    
    ```jsx
    1 + true;          // 2 (+ 연산자의 암묵적 타입 변환)
    +null;             // 0 (위와 동일, null은 숫자 0으로 변환됨)
    NaN === NaN;       // false (NaN은 자신과 일치하지 않는 유일한 값)
    0 === -0;          // true
    Object.is(0, -0);  // false (Object.is 메서드는 0과 -0을 구별함)
    typeof null;       // "object" (자바스크립트의 첫번째 버그)
    typeof NaN;        // "number" (NaN은 숫자 데이터 타입!)
    typeof foo;        // "undefined" (foo라는 변수가 선언되지 않았으므로 "undefined"를 반환합니다.)
    ```
    
- 내 대답
    1. true 가 불리언 → 실수 1 로 암묵적 타입변환이 일어나 **2 라는 값**이 평가된다.
    2. null 에 + 연산자를 붙여도 숫자타입으로 변환될 수 없으니 **NaN** 라고 출력된다.
    3. 일치 비교 연산자로 NaN 을 비교했을 때, **false 라는 불리언 값**이 평가된다.
    Number.isNaN 메서드를 사용해야 한다.
    4. 답 못함.
    5. false 로 나온다. Object.is 는 일치 비교 연산자와 같은 역할을 한다. - (+0, -0) 은 true로 평가됨.
    6. null 을 typeof 로 평가하면, Object 가 나옴. null 타입인지 알려면, 일치 연산자를 사용해야 함.
    7. Number 가 출력됨. 
    8. 초기화한 것을 typeof 로 평가하면 Object 가 출력됨.
- 꼬리 질문
    
    Q10-1. 위의 3번을 올바르게 평가하는 두가지 방법에 대해 설명하시오
    
    - 정답
        - `Number.isNan(NaN)`, `isNan(NaN)`
        - `Object.is(NaN, NaN)`
    - 내 대답
        1. Number.isNaN 으로 평가해야함.
        2. 모르겠음.

Q11. 개발자 도구 콘솔창에 `var foo = 10`을 입력한 결과와 그 이유를 설명하시오

- 정답
    
    !https://user-images.githubusercontent.com/70076564/253384768-f394faa1-edca-42a1-a489-ff38d6b54e97.png
    
    - `var foo = 10`은 선언문이자 할당문
    - 선언문 = 표현식이 아닌 문할당문 = 표현식인 문선언문+할당문 = 표현식이 아닌 문위 문은 변수에 값을 할당하는 사이드이펙트가 있을 뿐, 어떠한 값이 평가되지는 않는다. 따라서 완료값이 돼서 `undefined`가 찍힘+) return 뒤에 넣을 수 있으면 표현식인 문, 없으면 표현식이 아닌 문참고자료) [Why does console.log say undefined, and then the correct value?](https://stackoverflow.com/questions/24342748/why-does-console-log-say-undefined-and-then-the-correct-value)[console.log만 찍어도 undefined 나오는 이유](https://velog.io/@ingdol2/JS-console.log%EB%A7%8C-%EC%B0%8D%EC%96%B4%EB%8F%84-undefined-%EB%82%98%EC%98%A4%EB%8A%94-%EC%9D%B4%EC%9C%A0)
- 내 대답
    
    undefined 라고 나옴. foo 를 선언하고, 값을 할당했지만, 참조한 것은 없음.
    
- 꼬리 질문
    
    Q11-1. 완료값이란 무엇인가?
    
    - 정답
        
        크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력하는데, 이걸 완료값이라고 함. 표현식인 문을 실행하면 언제나 평가된 값을 반환.
        
    - 내 대답
        
        크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 완료 값이라 한다.
        완료 값은 표현식의 평가 결과가 아니다. 
        

Q12. `==`와 `===`의 차이점에 대해 설명하시오.

- 정답
    - `==`: 피연산자들을 암묵적 타입 변환으로 타입을 일치시킨 뒤 값을 비교, 사용 지양
    - `===`: 피연산자의 타입과 값이 모두 같을 경우에만 `true`
- 내 대답
    
    동등 비교 연산자(==) 는 좌항과 우항의 타입을 자바스크립트 엔진이 암묵적 타입 변환을 통해 일치시킨 후 일치하는 지 비교한다.
    
    일치 비교 연산자(===) 는 좌항과 우항의 타입과 값이 같아야 true 반환, 타입이나 값이 다르면 false 를 반환한다.
