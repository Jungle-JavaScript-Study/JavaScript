### 4장 변수
#### 4.1 변수란 무엇인가? 왜 필요한가?

```
10 + 20
```

자바스크립트로 위 코드를 실행하면 컴퓨터에서는 어떤 일이?
자바스크립트 엔진이 위 코드를 계산하려면 10, 20, + 라는 기호(리터럴literal과 연산자operator)를 알고 있어야 하며,
10 + 20 이라는 식(표현식expression)의 의미도 해석(파싱parsing)할 수 있어야 함.

컴퓨터는 cpu를 사용해 연산하고, 메모리를 사용해 데이터를 기억함.
메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체
메모리 셀 하나의 크기는 1바이트이며, 컴퓨터는 이 단위로 데이터를 읽고 쓰고 한다.

컴퓨터는 모든 데이터를 2진수로 처리함.
위 식의 결과인 30 또한 메모리 상의 임의의 위치에 2진수로 저장됨.

이 때 연산 결과로 나온 30을 재사용하기 위해서는 저장된 메모리에 직접 접근해야하는데,
이러면 치명적 오류가 발생할 수 있음.
-> 따라서, 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음.

허용해도 문제인게, 메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정됨.
-> 같은 코드를 실행해도 메모리 주소는 변경됨.

**메모리 주소를 통해 값에 직접 접근하는 시도는 올바른 방법이 아님!**

이것을 위해 변수가 있는 것.
변수의 정의: 
하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
-> 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름임.

변수는 하나의 값을 저장하기 위한 수단임.
```
// abc는 변수 이름, 1은 변수 값
var abc = 1;
```
객체나 배열 같은 자료구조를 사용하면, 여러 값을 하나로 그룹화해서 사용할 수 있음.
```
var abc = { id: 1, name: "kim" };

var abc = [
	{ id: 1, name: "Kim" },
    { id: 2, name: "Lee" }
];
```

#### 4.2 식별자
식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름임. (변수 이름을 식별자라고도 함.)

값은 메모리 공간에 저장돼있기 때문에 식별자는 어떤 값이 저장된 메모리 주소를 기억해야 함.

식별자는 값이 저장된 메모리 주소와 매핑 관계를 맺고, 이 매핑 정보도 메모리에 저장돼야 함.
**-> 식별자는 값이 아닌 메모리 주소를 기억하고 있음!**

변수, 함수, 클래스 등 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부름.

식별자는 네이밍 규칙 준수해야하고, 선언에 의해 자바스크립트 엔진에 존재를 알림.

#### 4.3 변수 선언
변수 선언은 변수 생성을 말함.
-> 값 저장하기 위한 메모리 공간을 확보하고 변수 이름과 메모리 공간의 주소를 연결해서 값 저장할 수 있게 준비하는 것.

확보된 메모리는 해체되기 전까지는 누구도 사용할 수 없도록 보호되므로 안전하게 사용 가능함.

변수를 사용하려면 반드시 선언 필요.
var, let, const 키워드를 사용함.
ES6에서 let, const 도입되기 전까지 var이 유일한 키워드였음.

```
var score
```
변수 선언 후 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화됨. (자바스크립트의 독특한 특징)

자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행.
선언 단계: 변수 이름 등록, 엔진에 변수의 존재를 알림.
초기화 단계: 값 저장 위한 메모리 공간 확보, 암묵적으로 undefined 할당해 초기화.

- 모든 식별자는 실행 컨텍스트에 등록됨. 실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드 실행 결과를 실제로 관리하는 영역임.
변수 이름은 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리됨.

var 키워드를 통한 변수 선언은 선언, 초기화 단계가 동시에 진행됨.
(자바스크립트는 쓰레기 값이 나올 위험으로부터 안전함)

선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러) 발생.

#### 4.4 변수 선언의 실행 시점과 변수 호이스팅
```javascript
console.log(score); // undefined

var score; // 변수 선언
```
변수 선언이 runtime이 아닌 이전 단계에서 먼저 실행되기 때문에 참조 에러 발생하지 않음.

자바스크립트 엔진은 순차적인 실행에 앞서 소스코드의 평가 과정을 거치고 소스코드 실행을 위한 준비를 함.
이 때, 모든 선언문을 찾아 먼저 실행함.
평가과정이 끝나면 모든 선언문을 제외하고 한 줄씩 순차적으로 실행함.
-> 어디서든지 변수 참조 가능

이렇듯 변수 선언문이 코드 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라고 함.

#### 4.5 값의 할당

```javascript
console.log(score); // undefined

var score;
score = 80;

console.log(score); // 80
```

```javascript
console.log(score); // undefined

var score = 80;

console.log(score); // 80
```

선언과 할당을 단축 표현해도 자바스크립트 엔진은 선언과 할당을 2개의 문으로 나눠 각각 실행하기 때문에 
위 두개는 동일하게 동작함.

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 80
```

위처럼 해도 같은 결과가 나온다.(신기하다)

#### 4.6 값의 재할당
엄밀하게는 처음에 할당하는 것도 재할당임. (암묵적 undefined 할당 -> 값 할당)
(const는 한 번만 할당할 수 있는 변수를 선언함.)

변수에 값 재할당하면, 원래 값이 있던 공간 지우는 게 아닌 새로운 메모리 공간 확보 후 그 공간에 새로운 값을 저장함.

변수의 이전 값처럼 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제됨. (단, 언제 해제될지는 예측 불가)

자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로, 이를 통해 메모리 누수를 방지함.
(매니지드, 언매니지드 언어는 일정한 생산성 확보(치명적 오류 제거)와 성능 간의 trade-off 존재함)

#### 4.7 식별자 네이밍 규칙
식별자는 문자(특수문자 제외), 숫자, 언더스코어, 달러 기호 포함가능, 숫자로 시작하는 것은 허용하지 않음.
예약어는 식별자로 사용할 수 없음.

변수는 쉼표로 구분해 한번에 선언 가능하지만 가독성이 안좋아지므로 권장 X
한글, 일본어 식별자도 사용 가능하지만 권장 X
자바스크립트는 대소문자를 구별함.

네이밍 컨벤션
camelCase, snake_case, PascalCase, typeHungarianCase가 자주 사용됨
```javascript
// typeHungarianCase
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

일관성 유지한다면 어떤 네이밍 컨벤션도 좋지만, 일반적으로 변수나 함수 이름에는 카멜 케이스를,
생성자 함수, 클래스 이름에는 파스칼 케이스 사용함.
ECMAScript 사양에 정의된 객체와 함수들도 마찬가지이므로 가독성 높이기 위해서 카멜 케이스, 파스칼 케이스 따르는 것이 유리함.
