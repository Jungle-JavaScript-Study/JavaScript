# 4-7 답변

Q1. `var`, `let`, `const`의 차이가 무엇인가?

- `var`: ES6 전까지 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였음. 함수 스코프. 동일한 이름의 변수를 여러 번 선언할 수 있음. 다음에 선언된 값으로 덮어씌워짐.
- `let`: 변수 선언 전에 참조하려고 하면 ReferenceError 발생함. 블록 스코프. 같은 스코프 내에서 다시 선언하려고 하면 SyntaxError 발생함.
- `const`: 상수(단 한 번만 할당할 수 있는 변수)를 선언 할 때 사용하는 키워드.

  
꼬리 질문
<br>Q1-1. 호이스팅에 관해 설명하시오<br>
자바스크립트의 특징으로 선언문이 위로 끌어올려지는 것처럼 동작하는 것을 말합니다.

<br>

Q2. 할당, 선언, 초기화, 참조에 대해 순서와 실행 시점을 포함하여 설명하시오

자바스크립트 엔진은 코드 실행에 앞서서, 소스코드를 평가하는 과정을 거칩니다. 
<br>이때, 모든 선언문을 먼저 확인한 다음, undefined로 초기화합니다.
<br>코드를 실행할 때는, 모든 선언문을 제외한 코드를 한 줄씩 내려가면서 실행합니다. 이 과정에서 할당이 이루어집니다.
<br>참조는 코드의 순서에 따라 할당 이전에 될 수도 이후에 될 수도 있을 것 같습니다.

꼬리 질문
<br>Q2-1. 변수에 값을 재할당할 때 일어나는 일을 설명하시오

기존의 메모리 공간을 값을 지우고 재사용하는 것이 아닌 새로운 메모리 공간을 확보하여 값을 저장합니다. 
<br>이때 재할당되기 전에 사용된 메모리 공간은 자바스크립트의 가비지 콜렉터가 해제합니다.

<br>

Q3. 자바스크립트에서의 최소 단위를 statement와 token의 관점에서 설명하시오

statement 관점에서는 statement는 자바스크립트에서 실행 가능한 최소한의 코드 블록입니다.
token은 자바스크립트 코드를 이루는 최소한의 구성 요소로, 문법적으로 더 이상 분해할 수 없는 최소 단위입니다.

Q4. undefined와 null에 대해 설명하시오

undefined는 초기화 상태로, 암묵적으로 할당되는 값이며, null은 명시적으로 없는 값임을 나타내기 위해 할당하는 값입니다.

<br>

Q5. 데이터에 타입이 필요한 이유는 무엇인가?

값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하고,
<br>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하고,
<br>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해서입니다.

<br>

Q7. c언어와 자바스크립트에서의 데이터 타입에서의 차이점을 설명하시오

c언어는 컴파일 시점에 타입 체크를 하며, 자바스크립트에서 변수는 선언이 아닌 할당에 의해 타입이 결정되며, 언제든지 동적 타이핑이 가능한 동적 타입 언어입니다.

꼬리 질문

Q7-1. 자바스크립트의 동적 타입 언어로서의 단점을 이야기하시오.

복잡한 프로그램에서는 타입을 추적하기 어려울 수 있고, 암묵적으로 타입이 변환되는 경우도 있기 때문에 위험할 수 있습니다.

<br>

Q8. 자바스크립트에서 2진수, 8진수, 10진수, 실수, 정수 변수를 표현하는 방법을 설명하시오.

자바스크립트는 하나의 숫자 타입만 존재하며, 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따릅니다.
즉 자바스크립트는 모든 숫자가 실수로 표현됩니다.
2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않으며 값을 참조하면 모두 10진수로 해석됩니다.
하지만 리터럴로 표현은 할 수 있습니다.
2진수는 0b로 시작, 8진수는 0o로 시작, 16진수는 0x로 시작합니다.

<br>

Q9. 암묵적 타입 변환에 대해 설명하시오

자바스크립트 엔진에 의해 암묵적으로 타입이 변환(강제 변환)되는 것입니다.

Q9-1. 암묵적 타입 변환이 일어나는 예시를 2가지 설명하시오.

숫자와 불리언 타입 간에 산술 연산자를 사용할 경우, +/- 단항 연산자를 사용하는 경우, 동등 비교 연산자를 사용하는 경우 등이 있습니다.

<br>

Q10. 다음의 연산 결과와 그 이유에 대해 설명하시오

```javascript
1 + true;         //1
+null;            //2
NaN === NaN;      //3
0 === -0;          //4
Object.is(0, -0); //5
typeof null;      //6
typeof NaN;       //7
typeof foo;       //8
```

1: 2 // true가 1로 암묵적 타입 변환이 되기 때문
<br>2: 0 // null은 값이 없다는 것인데 null 앞에 +를 붙임으로써 타입이 숫자로 강제 변환되기 때문에 0이 될 것 같습니다.
<br>3: false // NaN은 자기 자신과 다른 유일한 값입니다.
<br>4: 양의 0과 음의 0은 동등/일치 비교 연산자 모두 true를 반환합니다.
<br>5: false // 양의 0과 음의 0은 다르기 때문입니다.
<br>6: "Object" // 첫 번째 버전의 버그인데, 고치게 되면 기존 코드들에서 버그가 발생할까봐 아직까지 고쳐지지 않고 있습니다.
<br>7: NaN의 타입은 "number"네요 하하하
<br>8: "string"

꼬리 질문
<br>Q10-1. 위의 3번을 올바르게 평가하는 두가지 방법에 대해 설명하시오

빌트인 함수 Number.isNaN을 사용합니다.
Object.is(NaN, NaN); 을 사용합니다.

<br>

Q11. 개발자 도구 콘솔창에 var foo = 10을 입력한 결과와 그 이유를 설명하시오

할당하는 과정이라 undefined가 나올 것 같습니다.

꼬리 질문
<br>Q11-1. 완료값이란 무엇인가?

코드나 표현식을 실행할 때, 해당 실행이 완료될 때까지 기다렸다가 반환되는 값을 완료값이라고 합니다.

<br>

Q12. ==와 ===의 차이점에 대해 설명하시오.

==은 동등, ===은 일치 비교 연산자로써, 동등 비교 연산자는 타입을 암묵적 타입 변환을 시킨 다음 비교 연산을 하기 때문에 타입이 다르지만 일치할 가능성이 있는 변수의 경우 true를 반환할 수 있습니다.
반면 일치 비교 연산자는 타입까지 같은 경우에만 true를 반환하기 때문에 좀 더 안전하게 사용이 가능합니다.
