# 32장 String

### Q1. String 객체에는 원본 String 래퍼 객체를 직접 변경하는 메서드가 존재하지 않습니다. 그 이유가 무엇일까요?

<details>
<summary>정답</summary>

- 문자열은 변경 불가능한 원시 값이기 때문입니다.
- String 래퍼 객체는 읽기 전용 객체로 제공되고, String 객체의 메서드는 언제나 새로운 문자열을 반환합니다.

</details>

<br/>

# 33장 7번째 데이터 타입 Symbol

### Q2. 심벌이란?

<details>
<summary>정답</summary>

<br/>

- ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값입니다.
- 심벌 값은 다른 값과 중복되지 않는 유일무이한 값입니다.
- 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용합니다.

</details>

<br/>

### Q3. 심벌 값을 생성하는 방법

<details>
<summary>정답</summary>

<br/>
Symbol 함수를 호출하여 생성합니다.

</details>

<br/>

### Q4. Symbol 함수를 여러 번 호출하면서 동일한 문자열을 인수로 전달하면 어떻게 되나요?

<details>
<summary>정답</summary>

<br/>
생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되며, 심벌 값 생성에는 어떠한 영향도 주지 않습니다.
즉, 심벌 값에 대한 설명이 같더라도 생성된 심벌 값은 유일무이한 값입니다.

</details>

<br/>

### Q5. 심벌 값은 암묵적 타입 변환이 일어나나요?

<details>
<summary>정답</summary>

문자열이나 숫자 타입으로는 변환되지 않고 불리언 타입으로는 암묵적으로 타입 변환됩니다.

</details>

<br/>

### Q6. Symbol.for는 어떤 동작을 하나요?

<details>
<summary>정답</summary>

인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색합니다.

</details>

<br/>

### Q6-1. Symbol.for 메서드에서 심벌 값 검색에 실패하면 어떻게 동작하나요?

<details>
<summary>정답</summary>

새로운 심벌 값을 생성하여 인수로 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌 값을 반환합니다.

</details>

<br/>

### Q6-2. Symbol()로 생성한 심벌 값과 Symbol.for()로 생성한 심벌 값에는 어떤 차이가 있나요?

<details>
<summary>정답</summary>

- Symbol 함수로 생성한 심벌 값은 심벌 값을 검색할 수 있는 키를 지정할 수 없으므로 전역 심벌 레지스트리에 등록되어 관리되지 않습니다.
- Symbol.for 메서드를 사용하면 애플리케이션 전역에서 중복되지 않는 유일무이한 상수인 심벌 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유할 수 있습니다.

</details>

<br/>

### Q7. 심벌 값을 사용하여 프로퍼티를 은닉하는 방법

<details>
<summary>정답</summary>

<br/>

- 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티는 for...in 문이나 Object.keys, Object.getOwnPropertyNames 메서드로 찾을 수 없습니다.
- 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 생성하면 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있습니다.

</details>

<br/>

### Q7-1. 심벌 값으로 프로퍼티 키를 생성하면 프로퍼티를 완전하게 숨길 수 있나요?

<details>
<summary>정답</summary>

ES6에서 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있습니다.

</details>

<br/>

### Q8. 표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하는 것은 권장되지 않는데, 그 이유가 무엇일까요?

<details>
<summary>정답</summary>

미래에 표준 사양으로 추가될 메서드의 이름과 중복될 수 있기 때문입니다.

</details>

<br/>


### Q8-1. 표준 빌트인 객체에 메서드를 꼭 추가해야 한다면, 어떻게 하면 좋을까요?

<details>
<summary>정답</summary>

중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성합니다.
<br/>
기존 프로퍼티 키와 충돌하지 않는 것은 물론, 미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있습니다.

</details>

<br/>


# 34장 이터러블

### Q9. 이터레이션 프로토콜이란?

<details>
<summary>정답</summary>

ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 자료구조를 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙을 말합니다.

</details>

<br/>

### Q10. 이터러블이란?

<details>
<summary>정답</summary>

이터러블 프로토콜을 준수한 객체로,
Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말합니다.
이터러블은 for...of문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있습니다.

</details>

<br/>

### Q11. 이터러블 프로토콜을 준수하지 않는 일반 객체는 이터러블과 어떤 점이 다른가요?

<details>
<summary>정답</summary>

일반 객체는 for...of문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없습니다.
단, TC39 프로세스의 stage 4 단계에 제안되어 있는 스프레드 프로퍼티 제안은 일반 객체에 스프레드 문법의 사용을 허용합니다.

</details>

<br/>

### Q12. 이터레이터란?

<details>
<summary>정답</summary>

이터레이터 프로토콜을 준수한 객체를 이터레이터라고 하며,
이터레이터는 이터러블의 요소를 탐색하기 위한 포인터 역할을 합니다.

</details>

<br/>

### Q13. 이터레이터의 next 메서드는 어떤 역할을 하나요?

<details>
<summary>정답</summary>

- 이터러블의 각 요소르르 순회하기 위한 포인터의 역할을 합니다.
- next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환합니다.