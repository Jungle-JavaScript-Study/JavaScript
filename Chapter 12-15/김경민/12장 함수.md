## 12장 함수
### 12.1 함수란?
함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.

### 12.2 함수를 사용하는 이유
코드의 재사용 측면에서 유용, 유지보수 편의성 높임, 코드 신뢰성 높임, 코드 가독성 향상.

### 12.3 함수 리터럴
- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자임.
- 함수 이름 생략 가능
- 함수는 객체지만 일반 객체와는 다름.
- 일반 객체와 달리 함수는 호출 가능, 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티 가짐.

#### 12.4 함수 정의
함수 정의 방식에는 4가지 있음.
함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수

#### 12.4.1 함수 선언문 & 12.4.2 함수 표현식
- 함수 선언문은 함수 이름 생략 불가, 함수 리터럴은 이름 생략 가능(익명 함수)
- 함수 선언문은 표현식이 아닌 문임. 함수 표현식은 표현식인 문.
- 코드 문맥에 따라 함수 리터럴을 함수 선언문으로 해석하기도, 함수 리터럴 표현식으로 해석하기도 함.

#### 12.4.3 함수 생성 시점과 함수 호이스팅
- 함수 표현식으로 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생함.
- 함수 표현식 이전에 함수 참조하면 undefined, 이 때 함수 호출하면 undefined 호출하는 것과 마찬가지이므로
  타입 에러 발생.
- 함수 호이스팅은 함수 호출 전 반드시 함수 선언해야 한다는 당연한 규칙 무시하므로,
  함수 선언문 대신 함수 표현식 사용을 권장.

#### 12.4.4 Function 생성자 함수
- 일반적이지도 않고 바람직하지도 않음.
- 클로저를 생성하지 않음.

#### 12.4.5 화살표 함수
- 화살표 함수는 항상 익명 함수로 정의
- 기존 함수 선언문 또는 표현식 완전히 대체하기 위해 디자인된 건 아님.
- 생성자 함수로 사용할 수 없고, 기존 함수와 this 바인딩 방식 다름.
- prototype 프로퍼티 없음, arguments 객체 생성 안함.

### 12.5 함수 호출
- 함수는 매개변수의 개수와 인수 개수 일치하는지 체크하지 않음.
- 인수가 전달되지 않은 경우, 단축 평가를 사용해 매개변수에 기본값 할당할 수 있음.
- 이상적인 함수는 한 가지 일만 하고, 가급적 작아야 함.
- 함수 호출은 표현식임. 반환값으로 평가됨.
- 반환문은 함수 몸체 내부에서만 사용 가능함.

### 12.6 참조에 의한 전달과 외부 상태의 변경
원본 객체 변경되는 부수 효과 막기 위해, 객체를 불변 객체로 만들고,
상태 변경이 필요한 경우, 깊은 복사를 통해 새로운 객체 생성, 재할당을 통해 교체함.

### 12.7 다양한 함수의 형태
즉시 실행 함수, 재귀 함수, 중첩 함수, 콜백 함수, 순수/비순수 함수 등이 있음.