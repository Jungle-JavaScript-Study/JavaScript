Q1. 함수를 사용해서 코드를 작성하면 좋은 점을 말해보세요.

<details>
<summary>답</summary>

-  코드 재사용 측면에서 매우 유용하고 유지보수 편의성을 높이며, 실수를 줄여 코드의 신뢰성을 높일 수 있고, 적절함 함수 이름을 통해 코드의 가독성을 향상시킬 수 있습니다.<br>
</details>
<details>
<summary>꼬리 질문</summary> 
&nbsp;&nbsp;Q1-1. 함수를 정의하는 방법에는 어떤 게 있나요?
<details>
<summary>답</summary>

- 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수 이렇게 4가지 방법이 있습니다.<br>

    </details>
      <details>
    <summary>꼬리 질문</summary> 
    &nbsp;&nbsp;Q1-2. 함수 선언문에 대해 아는 대로 얘기해주세요.
      <summary>답</summary>

    -   함수 선언문은 함수 리터럴과 형태는 동일하지만 함수 리터럴과 달리 함수 이름을 생략할 수 없습니다.
    -   함수 선언문은 표현식이 아닌 문입니다.
    -   코드 문맥에 따라 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고, 함수 리터럴이 값으로 평가되어야 하는 문맥에서는 함수 리터럴 표현식으로 해석합니다.
      </details>
    </details>
    <br>

    Q2. 다음 코드 실행 결과를 말하고, 이유를 설명해주세요.

```javascript
  var add = function foo (x,y) {
    return x + y;
  };

  console.log(foo(3, 4));
```

  <details>
  <summary>답</summary>

-  ReferenceError가 발생합니다. (foo is not defined)
-  호출할 때 함수 객체를 가리키는 식별자가 아닌 몸체 내부에서만 유효한 식별자인 함수 이름으로 호출했기 때문입니다.
</details>
<br>

Q3. 다음 코드 실행 결과와 이유를 설명하세요.

```javascript
  function add(x, y) {
    return x + y;
  }

  console.log(add(2));
```

<details>
<summary>답</summary>

-   자바스크립트에서 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않습니다.
-   인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined이고, 함수 몸체에서 x + y는 2 + undefined와 같으므로 NaN이 반환될 것입니다.
</details>
<br>

Q4. 매개 변수에 객체를 인수로 사용하면 좋은 점과 주의할 점에 대해 말해보세요.

<details>
<summary>답</summary>

-   객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 됩니다.
-   또한 명시적으로 인수의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성이 좋아지고 실수를 줄일 수 있습니다.

-   주의할 점은 함수 내부로 전달한 객체를 변경하면 함수 외부의 객체가 변경되는 부수효과가 발생할 수 있다는 것입니다.

<details>
    <summary>꼬리 질문</summary> 
    &nbsp;&nbsp;Q4-1. 부수효과가 발생하는 문제를 어떻게 해결할 수 있을까요?

  <summary>답</summary>
    -  객체를 불변 객체로 만들어 사용합니다. 객체의 상태 변경이 필요한 경우에는 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체합니다.
</details>
</details>
<br>

Q5. 콜백 함수와 고차 함수란 무엇인가요?

<details>
<summary>답</summary>

-   함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며,
-   이러한 콜백 함수를 전달 받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차 함수라고 합니다.
-   고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있습니다. 
</details>
<br>

Q6. 순수 함수와 비순수 함수란 무엇이고 왜 순수 함수를 사용하는 것이 좋을까요?

<details>
<summary>답</summary> 
  
- 함수형 프로그래밍에서 어떤 외부 상태에 의존하거나 변경하지 않는, 즉 부수 효과가 없는 함수를 순수 함수라고 하고,
- 부수 효과가 있는 함수를 비순수 함수라고 합니다.
- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워지고, 예기치 못한 오류나 실수가 발생할 수 있기 때문에, 순수 함수를 사용하는 것이 좋습니다.
</details>
<details>
<summary>꼬리 질문</summary> 
  Q6-1. 외부 상태에는 어떤 것들이 있나요?

<details>
<summary>답</summary> 
  
  - 전역 변수, 서버 데이터, 파일, Console, DOM 등이 있습니다.
</details>
</details>
<br>

Q7. 다음 코드의 실행 결과를 예측해보고 이것이 자바스크립트의 어떠한 스코프 결정 방식에 의한 것인지 설명하세요.

```javascript
var x = 1000;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ???
bar(); // ???
```

<details>
<summary>답</summary>

- 자바스크립트는 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(정적 스코프)를 따릅니다.
- bar 함수는 전역에서 정의된 함수이기 때문에 전역 스코프를 상위 스코프로 사용합니다.
- 따라서 위 예제를 실행하면 전역 변수의 x의 값 1000이 두 번 출력됩니다.


</details>
<br>

Q8. 변수, 지역 변수, var 키워드로 선언한 전역 변수의 생명 주기에 대해 말해보세요.

<details>
<summary>답</summary> 
- 변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해체되어 가용 메모리 풀에 반환되는 시점까지입니다.
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치하고,
- var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치합니다.
</details>
<br>

Q9. 전역 변수의 문제점을 2가지 이상 말해보세요.

<details>
<summary>답</summary>

- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하기 때문에 코드의 가독성이 나빠지고, 의도치 않은 상태 변경의 위험성이 있습니다.
- 생명 주기가 길기 때문에 메모리 리소르를 오래 소비합니다. var 키워드의 경우에는 변수의 중복 선언도 허용하므로 의도치 않은 재할당이 이뤄질 수 있습니다.
- 스코프 체인 상에서 종점에 존재하기 때문에 전역 변수의 검색 속도가 가장 느립니다.
- 자바스크립트에서는 파일이 분리되어 있어도 하나의 전역 스코프를 공유하기 때문에 다른 파일에 동일한 이름의 전역 변수나 전역 함수가 있는 경우 예상치 못한 결과가 나타날 수 있습니다.
 
 <details>
    <summary>꼬리 질문</summary> 
    &nbsp;&nbsp;Q9-1. 그럼 전역 변수의 사용을 어떻게 억제할 수 있을까요?

  <summary>답</summary>
    -  즉시 실행 함수로 감싸면 변수가 즉시 실행 함수의 지역 변수가 되기 때문에 전역 변수의 사용을 제한 할 수 있습니다.
    -  ES6 모듈을 사용하면 파일 자체의 독자적인 모듈 스코프를 제공하기 때문에 모듈 내에서 var 키워드로 변수를 선언해도 전역 변수가 아니게 됩니다.
</details>
 
 </details>
 <br>
 Q10. var, let, const 키워드는 어떻게 사용하는 것이 좋을까요?

<details>
<summary>답</summary>

- ES6를 사용한다면 var 키워드는 사용하지 않는 게 좋습니다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용하고, 변수의 스코프는 최대한 좁게 만듭니다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를 사용합니다.
- 변수를 선언할 때 일단은 const 키워드를 사용한 다음, 반드시 재할당이 필요하면 let 키워드로 변경합니다.

</details>
 <br>
 Q11. 다음 코드의 1번에서 출력되는 값과 그 이유는 무엇인가요?

```javascript
var x = 'Hi';

function foo() {
  console.log(x); // 1번
  var x = 'Hello';
}

foo();
```
 

<details>
<summary>답</summary>

- 스코프 단위로 호이스팅이 동작하여 지역 변수 x는 1번에서 undefined로 초기화되어 있습니다.
- 아직 변수 할당문이 실행되지 않은 단계이기 떄문에 undefined 가 출력됩니다.

</details>



+ 스터디 당시 나온 추가 질문
Q. 함수 내의 변수가 소멸되고, 즉 변수의 생명주기가 끝났을 때, 왜 바로 가용 메모리로 돌려주지 않고 가비지 콜렉터에 의해 해제될 때까지 기다리는 건가요?

A. 가용 메모리로 바로 돌려주는 것이 항상 이상적인 상황은 아닙니다. 예외 상황들이 발생할 수 있으며, 이러한 상황들을 효율적으로 관리하기 위해서는 가비지 콜렉터가 필요합니다. 가비지 콜렉터는 메모리를 안전하게 관리하고, 불필요한 메모리 해제를 방지함으로써 애플리케이션의 안정성을 높입니다.

- + 옵저버 패턴을 사용하는 이유
    
    불변 객체를 사용하면 객체를 복사해야 하므로 메모리 사용량이 객체의 크기에 따라 선형적으로 증가하고, 이에따른 성능 저하가 발생할 수 있습니다.
    
    사용자의 패턴을 실시간으로 반영해야하는 경우 즉, 이벤트 기반 시스템일때 유용하게 사용됩니다.
