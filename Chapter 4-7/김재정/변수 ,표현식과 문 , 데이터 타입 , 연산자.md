**4.1 변수란 무엇인가? 왜 필요한가?**

애플리케이션은 데이터를 다룬다. 

변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

간단히 말하자면 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로 값의 위치를 가르키는 상징적인 이름이다.

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수이름** 이라고 한다. 그리고 변수에 저장된 값을 **변수 값** 이라고 한다. 

**4.2 식별자**

변수 이름을 식별자라고 한다.

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

사람을 이름으로 구별해서 식별하는 것처럼 값도 식별자로 구별해서 식별할 수 있다.

식별자는 값이 아니라 메모리 주소를 기억하고 있다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.

변수, 함수, 클래스등의 이름과 같은 식별자는 네이밍 규칙을 준수해야하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다. 

**4.3 변수 선언**

변수를 사용하려면 반드시 선언이 필요하자. 변수를 선언할때는 var, let, const 키워드를 사용한다. 

var은 단점이 있는데, 가장 대표적인것은 블록 레벨 스코프를 지원하지 않고 함수레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.

```c
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 출력: 5, 5, 5, 5, 5
  }, 1000);
}
```

var는 블록 범위가 아닌 함수 범위 변수이므로, setTimeout 콜백 함수가 실행될 때 이미 반복문이 종료되어 i의 값은 5가 된다.

자바스크립트 엔진은 변수 선언을 아래와 같은 2단계에 거쳐 수행한다.

1. 선언단계 : 변수 이름을 등록해서 JS엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로undifined를 할당해 초기화 한다.

위와 같은 단계가 수행되기 깨분에 변수 선언 시, 암묵적으로 undefined를 할당해 초기화 한다.

이러한 단계 덕분에 쓰레기 값 없이 안전하게 변수가 선언될 수 있는것이다.

**4.4 변수 선언의 실행 시점과 변수 호이스팅**

JS는 인터프리터 언어이다. 즉, 변수 선언이 소스코드가 한줄식 순차적으로 실행되는 시점, 즉, 런타임 이 아니라 그 이전 단계에서 먼저 실행된다.

그래서 코드를 한줄씩 순차적으로 실행하기 앞서 소스코드의 평과가정을 거치면서 소스코드를 실행하기 위한 준비를 하기때문에, 소스코드의 평과가정에서 자바스크립트는 변수선언을 포함한 모든 선언문을 소스코드에서 찾아내고 싱행한다. 그리고 소스코드의 평과가정이 끝나면 비로서 변수선언을 포함한 모든 선언문을 제어하고 소스코드를 한 줄씩, 순차적으로 실행한다.

즉, 변수선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 호이스팅이라고 한다.

**4.5 값의 할당**

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

**4.6 값의 재할당**

값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다. (const)

값을 재할당 하면 메모리 공간을 지우고 해당 메모리 공간에 값이 저장되는것이 아닌 새로운 메모리 공간을 확보하고 메모리 공간에 숫자 값을 저장한다.

더이상 필요하지 않은 값은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.

**4.7 식별자 네이밍 규칙**

**5.1 값**

값은 표현식, 평가되어 생성된 결과를 말한다. 

변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이라고 했다.

**5.2 리터럴**

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.

**5.3 표현식**

```c
2 + 3
"Hello, " + "world!"
myVariable
Math.random()
```

표현식은 값(value)을 생성하고 결과를 반환하는 코드 조각입니다

표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

값으로 평가될 수 있는 문은 모두 표현식이다.

**5.4 문**

```c
let x;
x = 10;
if (x > 5) {
  console.log("x는 5보다 큽니다.");
} else {
  console.log("x는 5보다 작거나 같습니다.");
}
```

문은 프로그램에서 특정 작업을 수행하는 코드 블록입니다.

문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.

토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

**5.5 세미콜론과 세미콜론 자동 삽입 기능**

세미콜론은 “문”의 종료를 나타낸다. 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체종결성

세미콜론 자동삽입 기능 API이 암묵적으로 수행됨

**5.6 표현식인 문과 표현식이 아닌 문**

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.

표현식 문 - 표현식이 평가되고 그 결과가 버려지는 문

```c
x + 5;
```

표현식이 아닌 문 - 값을 반환하지 않는 문 

```c
if (x > 5) {
  console.log("x는 5보다 큽니다.");
} else {
  console.log("x는 5보다 작거나 같습니다.");
}
```

표현식 - 값으로 평가되는 코드 조각

```c
let result = x + 5;
```

**6.0 데이터 타입**

데이터 타입은 값의 종류를 말한다.

자바스크립트의 모든 값은 데이터 타입을 갖는다.

**6.1 숫자타입**

**6.2 문자열 타입**

**6.3 템플릿 리터럴**

템플릿 리터럴은 일반적인 문자열과 비슷해보이지만 작은 따옴표 또는 큰 따옴표 같은 일반적인 따옴표 대신 백틱을 사용해 표현한다.

```c
var template = `Template literal`
console.log(template)
```

**6.3.1 멀티라인 문자열**

일반 문자열 내에서는 줄바꿈이 허용되지 않는다. 따라서 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시로 시작하는 이스케이스 시퀸스를 사용해야 한다.

**6.3.2 표현식 삽입**

문자열은 [를 사용해 연결할 수 있다.](https://www.notion.so/5f3e2b039b8e4b4f910fab3dcf5fb6aa?pvs=21)?

(생략)

**6.5 undefined타입**

var키워드로 선언한 변수는 암묵적으로 undefined로 초기화 된다.

변수선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질때 까지 빈 상태로 내버려두지 않고 자바스크립트가 **undefined**로 초기화 한다

**6.6 null 타입**

이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다. 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.

**6.7 심벌 타입**

심벌값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol함수를 호출해 생성한다. 이때 생성된 심벌 값은 외부에 노출되지 않으며 다른 값과 절대 중복되지 않는 값이다.

**6.9 데이터 타입의 필요성**

데이터 타입은 왜 필요한 것일까? 데이터 타입의 필요성에 대해 살펴보자

**6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조**

메모리 값을 저장하려면 먼저 확보해야 할 메모리공간의 크기를 결정해야 한다.

몇바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.
숫자타입이 저장되어있는 경우 8바이트 단위로 읽어들이지 않으면 값이 훼손된다. 그렇다면 컴퓨터는 한 번에 읽어 들여야 할 셀의 크기를
알아야 하는데 이때,자바스크립트 엔진 단계에서 숫자 타입으로 인식하여 8바이트 단위로 저장된다.

**6.9.2 데이터 타입에 의한 값 해석**
메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해 

**6.10 동적 타이핑**
1. 동적 타이핑 언어와 정적 타이핑 언어
c나 자바같은 정적타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야한다.
이를 명시적 타입선언이라 함
이를 통해 타입의 일관성으로 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다.
자바스크립트 에서는 값을 할당하는 시점에 변구 타입이 동적으로 결정되고 변수 타입을 언제든지 자유롭게 변경할 수 있다.
자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다, 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 
 이러한 특징을 "동적 타이핑"이라고 한다.

 변수는 타입을 갖지 않는다. 하지만 값은 타입을 가진다 현재 변수에 할당되어있는 값에 의해  변수의 타입이 동적으로 결정된다고 표현하는것이 더 적절하다.
 
 2. 동적 타입 언어와 변수
 동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 이러한 동적 타입 언어는 편리하다.
 하지만, 암묵적 타입이 자동으로 변환되어 잘못된 예측에 의해 작성된 프로그램은 당연히 오류를 뿜어낼 것이다. 결국 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다. 

**7.1 산술 연산자 (Arithmetic Operators):**

산술 연산자는 숫자 연산에 사용되는 연산자입니다.

- 덧셈 연산자 (+): 두 개의 값을 더합니다.
  예시: `let sum = 5 + 3;` (sum의 값은 8)

- 뺄셈 연산자 (-): 두 개의 값을 뺍니다.
  예시: `let difference = 10 - 4;` (difference의 값은 6)

- 곱셈 연산자 (*): 두 개의 값을 곱합니다.
  예시: `let product = 3 * 5;` (product의 값은 15)

- 나눗셈 연산자 (/): 첫 번째 값을 두 번째 값으로 나눕니다.
  예시: `let quotient = 12 / 3;` (quotient의 값은 4)

- 나머지 연산자 (%): 첫 번째 값을 두 번째 값으로 나눈 후 나머지를 반환합니다.
  예시: `let remainder = 10 % 3;` (remainder의 값은 1)

**7.2 할당 연산자 (Assignment Operators):**

할당 연산자는 변수에 값을 할당하는 데 사용되는 연산자입니다.

- 할당 (=): 오른쪽의 값을 왼쪽 변수에 할당합니다.
  예시: `let x = 5;` (x의 값은 5)

- 덧셈 후 할당 (+=): 왼쪽 변수에 오른쪽 값을 더한 후 결과를 왼쪽 변수에 할당합니다.
  예시: `x += 3;` (x의 값은 8)

- 뺄셈 후 할당 (-=): 왼쪽 변수에서 오른쪽 값을 뺀 후 결과를 왼쪽 변수에 할당합니다.
  예시: `x -= 2;` (x의 값은 6)

- 곱셈 후 할당 (*=): 왼쪽 변수에 오른쪽 값을 곱한 후 결과를 왼쪽 변수에 할당합니다.
  예시: `x *= 4;` (x의 값은 24)

- 나눗셈 후 할당 (/=): 왼쪽 변수를 오른쪽 값으로 나눈 후 결과를 왼쪽 변수에 할당합니다.
  예시: `x /= 6;` (x의 값은 4)

**7.3 비교 연산자 (Comparison Operators):**

비교 연산자는 값을 비교하고 참 또는 거짓을 반환하는 연산자입니다.

- 동등 비교 (==): 두 개의 값이 같으면 true를 반환합니다.
  예시: `let isEqual = 5 == 5;` (isEqual의 값은 true)

- 일치 비교 (===): 두 개의 값이 같고 타입도 같으면 true를 반환합니다.
  예시: `let isStrictEqual = 5 === '5';` (isStrictEqual의 값은 false)

- 부등 비교 (!=): 두 개의 값이 다르면 true를 반환합니다.
  예시: `let isNotEqual = 7 != 3;` (isNotEqual의 값은 true)

- 크기 비교 (> 또는 <): 첫 번째 값이 두 번째 값보다 크면 true를 반환합니다.
  예시: `let isGreater = 10 > 5;` (isGreater의 값은 true)

**7.4 삼항 조건 연산자 (Ternary Operator):**

삼항 조건 연산자는 조건에 따라 값을 선택하는 데 사용되는 연산자입니다.

- 조건 ? 참인 경우 값 : 거짓인 경우 값
  예시: `let x = (5 > 3) ? '참' : '거짓';` (x의 값은 '참')

**7.5 논리 연산자 (Logical Operators):**

논리 연산자는 논리적인 조건을 판단하는 데 사용되는 연산자입니다.

- 논리곱 (&&): 두 개의 조건이 모두 참일 때 true를 반환합니다.
  예시: `let result = (5 > 3) && (7 < 10);` (result의 값은 true)

- 논리합 (||): 두 개의 조건 중 하나라도 참이면 true를 반환합니다.
  예시: `let result = (5 > 3) || (7 > 10);` (result의 값은 true)

- 논리부정 (!): 조건의 반대 값을 반환합니다.
  예시: `let result = !(5 > 3);` (result의 값은 false)

**7.6 쉼표 연산자 (Comma Operator):**

쉼표 연산자는 여러 개의 표현식을 순서대로 평가하고 마지막 표현식의 결과를 반환합니다.

- 표현식1, 표현식2, ..., 표현식n
  예시: `let x = (3, 5);` (x의 값은 5)

**7.7 그룹 연산자 (Grouping Operator):**

그룹 연산자는 표현식을 그룹화하여 우선순위를 조절하는 데 사용됩니다.

- (표현식)
  예시: `let result = (2 + 3) * 4;` (result의 값은 20)

위의 예시들은 JavaScript에서 사용되는 연산자들을 다양한 상황과 함께 보여주고 있습니다. 이 연산자들을 이용하여 수치 계산, 값 할

당, 조건 판단, 논리적인 연산 등을 수행할 수 있습니다.