## 19. 프로토타입

- 자바스크립트는 명령형/함수형/프로토타입 기반 객체지향 프로그래밍 언어(원시 타입을 제외한 모든 것이 객체)
- **객치지향 프로그래밍**: 독립적 단위(=객체)의 집합으로 프로그램을 표현하려는 패러다임↔ 명령형 프로그래밍(프로그램을 명령어/함수의 목록으로 보는 절차지향적 관점)
- 추상화: 실체를 구분할 수 있는 여러 속성이 있는데 이 중 필요한 속성만 간추려 표현하는 것
- 객체: 여러 값들을 속성으로 하나의 논리적인 단위로 묶은 자료구조
- 객체지향 프로그래밍에서의 객체 = 상태(프로퍼티) + 동작(메서드)
- 객체지향 프로그래밍에서는 **상속**으로 다른 객체의 속성을 가져와서 쓸 수 있음 => 코드 재사용으로 중복 제거
    - 자스는 프로토타입 기반 상속 구현(어떤 객체의 상위 역할을 하는 프로토타입 객체를 상속받음)
- 생성자로 객체를 만들 때마다 내용이 같은 메서드가 계속 생김-> 프로토타입에 메서드 추가해서 해결
    
    ```jsx
    School.prototype.getTotal = function(){
      return this.students.length;
    }
    //School 생성자로 만들어진 모든 객체가 메서드를 공유함(상속받음)
    ```
    
- 모든 객체는 `[[Prototype]]` 내부 슬롯에 하나의 프로토타입에 대한 참조를 가짐(객체 생성 시점에 생성 방식에 따라 결정, 객체 리터럴로 만들면 `Object.prototype`, 생성자 함수로 만들면 생성자 함수의 prototype 프로퍼티, 프로토타입이 없으면 `null`)
- 객체->프로토타입 (간접)접근은 `__proto__`(객체가 소유한 프로퍼티는 아니지만 모든 객체는 `Object.prototype` 객체를 상속받기 때문에 사용 가능)
프로토타입->생성자함수 접근은 `contstructor`
생성자함수->인스턴스의 프로토타입 접근은 `생성자함수.prototype`
- `__proto__`는 접근자 프로퍼티 -> `__proto__`를 사용하면 getter와 setter를 호출해서 객체의 프로토타입(`[[prototype]]` 내부 슬롯의 값)에 접근하거나 바꿈 (프로토타입 체인은 단방향 연결리스트로 구현되어야 하는데 서로 참조하는 순환 참조 프로토타입 체인이 생기면 무한루프에 빠지기 때문에 `__proto__` 프로퍼티를 통해서만 접근할 수 있도록 되어 있음) 
=> 직접 상속으로 `Object.prototype`을 상속받지 않는 객체를 만들면 `__proto__` 프로퍼티가 `undefined`로 뜨기 때문에 `__proto__`보다는 `Object.getPrototypeOf()`(ES5), `Object.setPrototypeOf`(ES6) 사용을 권장(없을 때 `null`로 뜸)
- **생성자 함수**로 호출될 수 있는 함수 객체는 생성할 인스턴스의 프로토타입을 가리키는 `prototype` 프로퍼티를 가짐(화살표 함수나 `function` 생략하고 선언한 축약 표현은 안됨) -> 함수 객체의 `prototype`과 모든 객체의 `__proto__`는 같은 프로토타입을 가리킴, 사용 주체 차이
    
  ![image](https://github.com/Jungle-JavaScript-Study/JavaScript/assets/70076564/4f2da1a1-e8f4-4f1f-a296-ba00abfbfa36)

    - `생성자 함수.prototype` = `인스턴스.__proto__`
    - 그치만 `생성자 함수.__proto__` = `인스턴스.__proto__`는 아님
        
      ![image](https://github.com/Jungle-JavaScript-Study/JavaScript/assets/70076564/57dcb22e-363f-4b7d-827c-046ed0b794e2)
        
- 모든 프로토타입은 `constructor` 프로퍼티를 가지고 <`prototype`으로 자신을 참조하는> 생성자 함수를 가리킴 → 생성자 함수로 객체를 생성하면 생성된 객체가 상속받은 프로토타입(`__proto__`)의 `constructor`가 생성자 함수를 가리키게 됨
⇒ 생성자 함수&프로토타입은 항상 쌍으로 존재!
(프로토타입의 constructor는 생성자 함수를 가리키고 생성자 함수의 prototype은 프로토타입을 참조하는 관계)
- 리터럴 표기법으로 객체를 만들면 `OrdinaryObjectCreate`를 호출해서 빈 객체를 생성한 뒤에 프로퍼티 추가 ⇒ `Object` 생성자 함수로 만들어진 객체는 아니지만 `Object` 생성자 함수를 가상적인 생성자 함수로 가져서 `constructor`로 연결돼있긴 함 => `constructor`로 연결된 생성자 함수를 해당 객체를 만든 생성자 함수로 생각해도 됨
- 생성자 함수가 생성될 때 프로토타입도 생성됨 => 항상 쌍으로 존재
    - 사용자 정의 생성자 함수
        - constructor(함수 선언문&표현식):  선언문이 호이스팅되면서 코드 선두에서 정의가 평가되어 함수 객체가 생성될 때 프로토타입도 같이 생성돼서 생성자 함수의 `prototype` 프로퍼티에 바인딩됨
            - 프로토타입의 프로토타입은 항상 `Object.prototype`
        - non-constructor(화살표 함수&축약 표현): 프로토타입 생성되지 않음
    - 빌트인 생성자 함수
        - 전역 객체가 생성될 때 빌트인 생성자 함수가 생성되기 때문에 프로토타입도 그 때 생성돼서 빌트인 생성자 함수의 `prototype` 프로퍼티에 바인딩 됨
    
    ⇒ 객체가 생성되기 전에 생성자 함수&프로토타입은 이미 객체화되어 존재, 이후 객체가 생성되면 상속받아서 `[[Prototype]]` 내부 슬롯에 할당됨
    
- 객체가 상속받는 프로토타입은 생성 방식에 따라 결정, `OrdinaryObejctCreate`가 인수로 전달받은 프로토타입을 `[[Prototype]]` 내부 슬롯에 할당해서 결정됨
    - 객체 리터럴 or `Object` 생성자 함수로 생성하면 `Object.prototype`, 사용자 정의 생성자 함수로 생성하면 `사용자 정의 생성자 함수.prototype` 상속받음
    - `Object.prototype`은 `hasOwnProperty`등의 빌트인 메서드가 있지만 사용자 정의 `생성자함수.prototype`에는 `constructor` 밖에 없음
- 프로토타입 체인: 자스가 객체지향 프로그래밍의 ‘상속’을 구현하는 메커니즘, 객체의 프로퍼티에 접근했는데 없으면 `[[Prototype]]` 내부 슬롯의 참조를 따라 부모 프로토탕입의 프로퍼티를 순차적으로 검색하는 메커니즘
    - 이 때 호출되는 메서드의 `this`에는 처음 검색 시작한 인스턴스 객체가 바인딩된다(`.call()`로 호출되기 때문)
    - 프로토타입 체인의 종점은 `Object.prototype`, `Object.prototype`의 프로토타입은 `null` 
    ⇒프로토타입 체인의 최상위는 언제나 `Object.prototype`라서 모든 객체는 `Object.prototype`을 상속받는다는 뜻
    - `Object.prototype`에서도 프로퍼티가 없으면 에러 없이 `undefined` 리턴
    - 프로토타입 체인은 상속&프로퍼티 검색을 위한 메커니즘, 스코프 체인은 식별자 검색을 위한 메커니즘
- 프로퍼티 섀도잉: 프로토타입 프로퍼티와 같은 이름의 인스턴스 프로퍼티를 추가하면 기존의 프로토타입 프로퍼티를 덮어쓰는게 아니라 인스턴스 프로퍼티로 추가되어 오버라이딩하는 현상
- 하위 객체를 통해 상위 프로토타입에 접근하는건 되지만 변경은 안됨
- 프로토타입을 생성자 함수/인스턴스로 동적으로 변경하면 `constructor` 프로퍼티-생성자 함수 연결이 끊어짐, 수동으로 다시 넣어줘야 함
    - `생성자 함수.prototype`으로 교체하면 앞으로 생성자 함수가 생성할 모든 인스턴스에 영향 미침, `인스턴스.__proto__`로 교체하면 그 인스턴스에만 영향 ⇒ 프로토타입은 직접 바꾸는 것보다 직접상속을 권장
- `<객체> instanceof <생성자 함수>` : <`생성자 함수.prototype`에 바인딩된 객체>가 <객체>의 프로토타입 체인에 존재하면 `true` ⇒ 프로토타입을 동적으로 변경해서 `contstructor`-생성자 함수 연결이 끊어져도 `prototype` 프로퍼티-프로토타입 연결이 끊어지는건 아니므로 `instanceof`는 영향 X
- 직접 상속: `Object.create()`로 프로토타입 전달하면서 객체 생성하기 or 객체 리터럴 내부에서 __proto__로 프로토타입 정의
    - 생성한 객체가 `Object.prototype`을 상속받긴 하지만 빌트인 메서드를 직접 호출하지는 말고 `.call()`로 객체 전달해서 사용하기
- 정적 프로퍼티(메서드): 생성자 함수가 객체로서 프로퍼티를 소유하면 생성자 함수로 만든 인스턴스는 접근할 수 없음(프로토타입의 프로퍼티가 아니기 때문), 프로토타입 프로퍼티는 인스턴스를 생성해야 하지만 정적 프로퍼티는 생성하지 않아도 접근 가능
- `key in obj`: 객체 내에 특정 프로퍼티 존재 확인, 상속받은 모든 프로토타입의 프로퍼티를 확인함(=`Reflect.has`(ES6))→ `Object.prototype.hasOwnProperty()`는 상속받은건 확인 X
- `for … in`도 상속받은 프로토타입 프로퍼티까지 열거하지만 `Object.prototype`의 프로퍼티가 안나오는 이유는 `Enumerable`이 `false`라서(키가 심벌이어도 열거하지 않음) → `Object.keys`/`values`/`entries` 사용하면 상속받은건 열거 X


## 21. 빌트인 객체

- 자바스크립트 객체는 3종류
    1. 표준 빌트인 객체
        - ECMAScript에 정의, 실행 환경에 관계없이 전역으로 사용 가능
        - `Math`, `Reflect`, `JSON`은 생성자 함수가 아닌 표준 빌트인 객체라서 정적 메서드만 제공, 나머지 표준 빌트인 객체는 모두 생성자 함수 객체라서 프로토타입 메서드(Ex. `str.length()`)&정적 메서드(인스턴스 없이도 호출 가능, Ex. `String.raw(str)`) 제공
        - 문자열/숫자/불리언 원시값을 객체처럼 사용하려고 하면 자바스크립트 엔진이 암묵적으로 임시 객체(=래퍼 객체)를 생성해서 사용하고 다시 원시값으로 되돌림 -> 래퍼 객체가 상속받은 프로토타입의 메서드를 사용할 수는 있으나 호출이 끝난 뒤에 래퍼 객체는 가비지 컬렉션의 대상이 되므로 실행한 내용이 저장되지 않고 다시 호출하면 완전히 새로운 래퍼 객체가 생성됨
        (※`null`/`undefined`는 래퍼객체 생성 안됨)<br>
        => 문자열/숫자/불리언은 생성자 함수로 생성할 필요가 없음
    2. 호스트 객체
        - ECMAScript에 정의돼있지는 않지만 실행 환경에서 추가 제공, 브라우저에서는 클라이언트 Web API, Node.js에서는 Node.js만의 API가 해당
    3. 사용자 정의 객체

### 전역 객체

- 코드가 실행되기 전에 자바스크립트 엔진이 가장 먼저 생성하는 최상위 객체, 어떤 다른 객체에도 속하지 않음
- 프로토타입 상속 관계에서 최상위라는게 아니라 어떤 객체의 프로퍼티로 속하지도 않으면서 객체의 계층적 구조상 표준 빌트인 객체&호스트 객체를 프로퍼티로 가진다는 의미
- 브라우저에서는 `window`/`self`/`this`/`frames`, Node.js에서는 `global`
    - ES11에서는 다 통일한 `globalThis`가 생김
- 표준 빌트인 객체/호스트 객체/전역 변수(`var`)/암묵적 전역/전역 함수를 프로퍼티로 가짐 <br>(`let`/`const`는 전역 객체의 프로퍼티가 아님)
- 개발자가 생성 불가(생성자 함수가 없음)
- 프로퍼티/메서드 참조할 때 `window`/`global` 생략 가능 => 전역 변수/전역 함수처럼 사용 가능
- 브라우저 환경의 모든 코드는 (`script`로 분리되어 있어도) 하나의 전역 객체 `window`를 공유
- 빌트인 전역 프로퍼티: 전역 객체의 프로퍼티, 앱 전역에서 사용하는 값
    - `Infinity`: number 타입
    - `NaN`: number 타입
    - `undefined`: 원시값
- 빌트인 전역 함수: 전역 객체의 메서드
    - `eval`: 전달받은 문자열을 평가하거나 실행, 모든 문을 실행해서 결과값을 반환
        - 객체/함수 리터럴은 반드시 괄호로 감싸야 함(Ex. `eval('({a:1})')`)
        - 런타임에 자신이 호출된 위치의 스코프를 동적으로 수정함 (※ strict mode에서는 수정 없이 자체적인 스코프 생성)
        - 전달받은 코드가 `let`/`const`를 사용하면 암묵적으로 strict mode 적용<br>
        
        => 보안에 취약하고 처리 속도가 느리므로 사용 금지
        
    - `isFinite`: 인수가 유한수인지 검사해서 불리언 리턴
        - 숫자가 아닌걸 전달받으면 숫자로 변환 => `null`은 숫자 `0`으로 변환되기 때문에 `true` 리턴
        - 인수가 `NaN`이면 `false` 리턴
    - `isNaN`: 인수가 `NaN`인지 검사해서 불리언 리턴(숫자로 타입 변환)
        - `''`와 `' '`는 숫자 `0`으로 변환돼서 `false` 리턴
    - `parseFloat`: 문자열 인수를 실수로 해석해서 리턴
        - 공백이 포함된 문자열은 첫번째 문자열만 변환(맨 앞과 맨 뒤의 공백은 무시)
        - 변환 불가는 `NaN` 리턴
    - `parseInt`: 문자열을 정수로 해석해서 리턴
        - 문자열이 아니면 문자열로 변환한 뒤에 정수로 해석
        - 두번째 인수로 진법(2~36) 전달하면 첫번째 인수를 해당 진수로 해석하고 결과값을 10진수로 리턴 (ㅇ진수->10진수 변환, 10진수->ㅇ진수 변환은 `Number.prototype.toString()` 사용)
        - 두번째 인수 전달 안해도 첫번째 인수가 `0x`/`0X`면 16진수로 해석(2진수는 안됨, 8진수는 ES6전까지만 가능)
        - 해당 진법으로 해석 안되면 `NaN`
        - 해당 진법으로 해석할 수 있는데까지만 해석하고 그 이후는 무시해서 리턴
        - 공백이 포함된 문자열은 첫번째 문자열만 변환(맨 앞과 맨 뒤의 공백은 무시)
        - `encodeURI`/`decodeURI`: URI를 문자열로 전달받아 이스케이프 처리(아스키 문자 세트로 변환)
        - `encodeURIComponent`/`decodeURIComponent`: URI 구성 요소를 전달받아 이스케이프 처리
- 암묵적 전역: 선언하지 않은 변수에 할당하면 전역 객체헤 프로퍼티가 동적 생성됨
    - 변수는 아니라서 변수 호이스팅은 안 일어남
    - 프로퍼티라서 `delete`로 삭제 가능
