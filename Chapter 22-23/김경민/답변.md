1. `this`란 무엇인가?

답변. JavaScript에서 this라는 키워드는 현재 실행 맥락에서 작동하는 객체를 가리킵니다. 즉, this는 코드에서 호출된 함수 내부에서 접근 가능한 변수 <br>
전역 객체: 전역 스코프에서 this를 사용하면, 전역 객체(window 또는 global)를 가리킵니다. <br>
객체와 메서드에서의 this: 객체의 메서드에서 this를 사용하면 해당 객체를 가리킵니다. <br>
생성자 함수나 클래스 내부에서 this: 생성자 함수나 클래스의 인스턴스를 만들 때 this는 새로 생성되는 객체 인스턴스를 가리킵니다.<br><br>

3. `this`를 생성하는 건 누구인가? 함수 내부에서는 어떻게 전달받는가?

답변. JavaScript에서 this는 누구도 생성하지 않습니다. 
자바스크립트 엔진에서 암묵적으로 생성됩니다.
도입부에서 언급했듯이, this는 실행 맥락에 따라 이미 존재하는 객체를 참조하는 키워드입니다. 따라서 함수 내부에서 this의 값을 전달받는 것은 실행 맥락에 따라 달라집니다. <br>

    
4. `this` 바인딩이 결정되는 시점은 언제인가?

답변. 

JavaScript에서 this 바인딩은 대개 호출 시점에 결정됩니다.

5. `this`에 바인딩되는 값은 어떻게 결정되는가?

답변. 

함수가 어떻게 호출되었는지에 따라 this의 값이 달라집니다.

<summary>꼬리 질문</summary>

`this`에 바인딩되는 값을 함수 호출 방식에 따라 4가지로 분류하여 설명하시오.

<details>
<summary>힌트</summary>

일반 함수 호출, 메서드 호출, 생성자 함수 호출, 간접 호출

</details>

기본 바인딩 (Default Binding):

함수를 일반 함수 호출로 실행하는 경우, this는 전역 객체를 참조합니다(브라우저에서는 window). 하지만, strict mode에서는 undefined입니다.

암시적 바인딩 (Implicit Binding):

객체의 메서드나 함수를 호출할 때, this는 해당 객체에 바인딩됩니다.

명시적 바인딩 (Explicit Binding):

call, apply, bind와 같은 메서드들을 사용하여 this를 특정 객체에 바로 바인딩할 수 있습니다.

new 바인딩 (Constructor Binding):

new 키워드로 생성자 함수를 호출하면, this는 새로 생성된 객체를 참조합니다.

Arrow Function의 바인딩:

ES6 화살표 함수는 자신만의 this 바인딩을 생성하지 않습니다. 대신, 화살표 함수는 자신을 둘러싼 코드의 this를 캡처합니다.


7. 전역에서 `this`가 호출되었을 때 바인딩되는 값을 2가지 말하시오.

답변.

전역 컨텍스트에서 this가 참조하는 값은 실행 환경에 따라 다릅니다. 주로 다음 두 가지 경우를 볼 수 있습니다:

브라우저 환경: 전역에서 this는 window 객체를 참조합니다.

Node.js 환경: Node.js에서 전역 스코프에서의 this는 global 객체에 바인딩됩니다. global 객체는 Node.js 환경에서 제공되는 전역 메서드와 속성을 포함하고 있습니다.
        
8. 다음 코드에서 출력되는 값과 그 이유를 설명하시오.
    
    ```javascript
    // 1번
    var value = 1; 
    
    const obj = {
    	value: 2,
    	foo() {
    		console.log("1:", this); 
    
    		setTimeout(function () {
    			console.log("2:", this); 
    			console.log("3:", this.value); 
    		}, 100);
    	}
    };
    obj.foo();
    ```
    
    ```jsx
    // 2번
    var value = 1;
    
    const obj = {
    	value: 2,
    	foo() {
    		console.log("1:", this); 
    		console.log("2:", this.value);
    
    	function bar() {
    		console.log("3:", this);
    		console.log("4:", this.value);
    		bar();
    	}
    };
    
    obj.foo();
    ```
1번 함수
1: { value: 2, foo: [Function: foo] } <br>
2: Window {...} <br>
3: 1 <br>

2번 함수

1: { value: 2, foo: [Function: foo] } <br>
2: 2 <br>
3: Window {...} <br>
4: 1 (전역 변수 value를 참조) <br>

콜백함수, 중첩함수도 일반 함수로 호출되면 전역 객체가 바인딩된다.

    <details>
    <summary>꼬리 질문</summary>

    중첩 함수/콜백 함수에서의 `this`를 메서드의 `this`와 일치시키는 방법을 세가지 설명하시오. 

    답변.

    bind 메서드 사용:
Function.prototype.bind 메서드를 사용하면 함수의 this 값을 명시적으로 지정할 수 있습니다.

    Arrow Function 사용:
화살표 함수는 자신만의 this 바인딩을 생성하지 않습니다. 대신 선언될 때의 상위 스코프의 this 값을 캡처합니다. 이를 이용하면 메서드의 this를 콜백 함수에서 그대로 사용할 수 있습니다.

    임시 변수 사용 (예: self 또는 that):
this 값을 임시 변수에 저장하고, 콜백 함수 내에서 이 변수를 참조하는 방법입니다. 이 패턴은 ES6의 화살표 함수가 도입되기 전에 주로 사용되었습니다.


7. ECMAScript 사양에서 소스코드를 구분하는 4가지 타입을 설명하시오.

전역 코드, 함수 코드, 모듈 코드, 스크립트 코드(eval)

8. 소스코드의 실행 과정을 평가와 실행으로 나누어 설명하시오

평가(Evaluation) 단계:
실행 컨텍스트를 만들고, 변수와 함수 선언을 찾고, 식별자와 할당에 대한 정의를 이해합니다. 또한, 호이스팅(hoisting)이 발생하며, 변수와 함수 선언이 현재 스코프의 맨 위로 끌어올려집니다. 평가 단계에서 다음과 같은 일들이 일어납니다:

소스 코드를 토큰(token) 단위로 분리하여 문서 구조를 파악합니다.<br>
구문 분석을 통해 추상 구문 트리(Abstract Syntax Tree, AST)를 생성합니다.<br>
변수와 함수 선언에 대한 정보를 수집하고 메모리를 확보한 후, 초기화 과정을 거칩니다(호이스팅 발생).<br>
렉시컬 환경(Lexical Environment)을 설정하고 스코프 체인을 구성합니다.<br><br>
실행(Execution) 단계:
평가 단계에서 처리된 결과를 기반으로 소스 코드가 실제로 실행되는 단계입니다. <br> 이때, 자바스크립트 엔진은 명령어들을 순차적으로 실행하여 변수에 값을 할당하고, 함수를 호출하며 프로그램이 구현한 로직과 연산을 처리합니다. 실행 단계에서 다음과 같은 일들이 일어납니다:
변수 할당, 함수 호출 등 실제 코드가 순차적으로 실행됩니다.
필요한 메모리가 할당되고 변수와 함수 식별자를 실제 값으로 치환합니다.
조건문, 반복문, 객체나 배열의 생성 및 조작 등 프로그램 로직 수행이 이루어집니다.
함수 호출 시 콜스택에 함수를 쌓았다가 반환될 때쌓인 순서에 따라 제거하는 과정을 진행합니다.

12. 실행 컨텍스트란?

실행 컨텍스트(Execution Context)는 자바스크립트 코드를 실행할 때 생성되고 관리되는 실행 환경에 대한 정보를 담고 있습니다. 실행 컨텍스트의 구성 요소는 다음과 같습니다:

LexicalEnvironment 컴포넌트: 자바스크립트 코드가 실행되면서 현재 스코프에 있는 변수, 함수 선언, 객체 등의 정보를 추적하고 저장하는 데 사용되는 렉시컬 환경입니다. LexicalEnvironment 컴포넌트는 실행 중인 코드에 대한 식별자 정보를 제공하며, 이 정보를 바탕으로 실제 메모리에서 값을 읽거나 업데이트할 수 있습니다.

VariableEnvironment 컴포넌트: 이 컴포넌트 역시 렉시컬 환경입니다. 하지만, LexicalEnvironment와의 차이점은 VariableEnvironment 컴포넌트가 변수 객체와 호이스팅(Hoisting)에 관한 정보를 포함한다는 것입니다. 호이스팅이 일어난 후 생성된 변수와 함수 선언에 대한 초기 정보를 추적하기 위해 사용됩니다.

ThisBinding 컴포넌트: 자바스크립트에서 this 참조를 관리합니다. 함수 내에서 this 키워드를 사용할 때 참조되는 객체 정보를 담고 있으며, 그 값과 관련된 바인딩 정보를 포함합니다.

13. 실행 컨텍스트는 어떤 구조로 관리되는가? 함수의 호출을 예로 들어 설명하시오.

스택
코드가 실행될 때 해당 코드의 실행 컨텍스트를 실행 컨텍스트 스택에 저장해두고 함수가 호출되면 해당 함수의 실행 컨텍스트를 그 위로 쌓는다.

함수 실행이 종료되면 해당 실행 컨텍스트를 스택에서 팝한다.
        
14. 렉시컬 환경을 구성하는 두가지 컴포넌트에 대해 설명하시오

환경 레코드와 외부 렉시컬 환경에 대한 참조.

15. ``if``문 내에서 `let`으로 변수를 선언했을 때의 렉시컬 환경의 변화를 설명하시오.

let, const로 선언한 변수는 블록 레벨 스코프를 따르기 때문에 함수뿐만 아니라 반복문, try-catch문 등의 코드 블록도 지역 스코프로 인정한다.

if문의 코드 블록이 실행되면 블록 레벨 스코프 생성을 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 생성해서 기존의 전역 렉시컬 환경을 교체한다. <br>
이때 새롭게 생성된 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if문의 실행되기 이전의 전역 렉시컬 환경을 가리킨다. if문 실행이 종료되면 if문이 실행되기 전의 렉시컬 환경으로 되돌린다.