## 22. `this`

- 리터럴 객체는 메서드에 접근하는 시점이 객체 리터럴이 평가된 이후이므로 변수명으로 자기 참조 가능, 생성자 함수 객체에서는 인스턴스 생성 전에 메서드 정의하므로 참조 불가능 → `this` : 객체의 프로퍼티나 메서드를 참조하기 위해 자신이나 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
- 바인딩: 식별자와 메모리 공간을 연결하는 것
- 자스 엔진에 의해 암묵적으로 생성되고 함수 호출할 때 암묵적으로 전달됨

### `this` 바인딩은 함수 호출 시점에 결정됨(함수 객체가 생성될 때 X)

- 전역이나 일반 함수 내부: 전역 객체 (※ strict mode 적용되면 `undefined`)
- 어떤 함수여도 **일반 함수**로 호출되면 `this`는 전역 객체 (브라우저에서는 `window`, Node.js에서는 `global`) (메서드 내의 중첩함수나 콜백함수도!)
→ `var`는 전역 변수로 전역 객체의 프로퍼티라서 이걸 사용하게 됨
⇒ 중첩 함수/콜백 함수에서의 `this`를 메서드의 `this`랑 같게 하려면
    1. `this`를 따로 변수에 할당해서 사용
        
        ```jsx
        const obj = {
          value: 100,
          const that = this;
          setTimeout(function () {
            console.log(that.value);
          },1000)
        }
        
        ```
        
    2. `Function.prototype.apply/call/bind`로 명시적 바인딩
        
        ```jsx
        const obj = {
          value: 100,
          setTimeout(function () {
            console.log(this.value);
          }.bind(this),1000)
        }
        
        ```
        
    3. 화살표 함수 내부의 `this`는 상위 스코프의 `this`
        
        ```jsx
        const obj = {
          value: 100,
          setTimeout(() => {
            console.log(this.value);
          },1000)
        }
        
        ```
        
- 객체 리터럴의 메서드 함수 내: **호출한** 객체 (소유한 객체 X)
    - 객체의 메서드는 객체에 포함된게 아니라 독립적으로 존재하는 객체를 프로퍼티에 바인딩해놓은 것 -> 다른 객체의 메서드로 할당하면 `this`는 새로운 객체를 가리킴, 변수에 할당해서 일반 함수로 호출하면 전역 객체를 가리킴
- 생성자 함수 내부: 생성할 인스턴스
-> `new`로 호출하지 않으면 일반함수가 돼서 `this`가 전역 객체를 가리키게 되는 것 주의
- `Function.prototype.apply/call/bind`로 간접 호출: 전달받은 첫번째 인수
    - `.apply`/`.call`은 바인딩해서 함수 호출 (`.apply(this객체, [함수의 인수])`/`.call(this객체, 인수1, 2, 3)`) -> 유사 배열이라서 배열 메서드를 사용할 수 없을 때 `.call`/`.apply`로 전달하면 사용 가능
    - `.bind`는 바인딩한 함수 리턴 -> 일반 함수로 호출된 메서드 내 중첩/콜백함수의 `this`를 메서드의 `this`와 일치시킬 때 사용

## 23. 실행 컨텍스트

- 소스코드 타입 4가지
①전역 코드 ②함수 코드 ③eval 코드 ④모듈 코드
- 소스코드 실행 과정) 코드 평가 (실행 컨텍스트 생성 → 선언문 평가해서 (실행 컨텍스트가 관리하는) 스코프에 등록) + 런타임 시작(코드 실행)(변수를 스코프에서 참조 → 실행 결과를 스코프에 등록)
- 실행 컨텍스트ㅣ 식별자 관리하는 스코프(렉시컬 환경)&코드 실행 순서 관리(실행 컨텍스트 스택)를 구현한 내부 메커니즘
- 실행 컨텍스트 스택: 스택 구조로 실행 순서 관리
- 실행중인 실행 컨텍스트: 실행 컨텍스트 스택의 최상위에 있는 실행 컨텍스트는 항상 현재 실행중인 코드의 실행 컨텍스트
- 렉시컬 환경: 식별자, 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조, 렉시컬 스코프의 실체
- 실행 컨텍스트: `LexicalEnvironment` 컴포넌트 + `VariableEnvironment` 컴포넌트
    - 생성 초기에는 동일한 렉시컬 환경 참조, 이후 새로운 렉시컬 환경을 생성해 VariableEnvironment의 참조 변경
    - 렉시컬 환경 = `EnvironmentRecord`(환경 레코드-스코프에 포함된 식별자 등록&바인딩 값 관리하는 저장소) + `OuterLexicalEnvironmentReference`(외부 렉시컬 환경에 대한 참조-상위 스코프를 가리킴, 스코프 체인 구현에 사용)
- 실행 컨텍스트 생성
    1. 전역 객체 생성
    2. 전역 코드 평가
        1. 전역 실행 컨텍스트 생성&실행 컨텍스트 스택에 푸시
        2. 전역 렉시컬 환경 생성&전역 실행 컨텍스트에 바인딩
        3. 전역 환경 레코드 생성
            1. 객체 환경 레코드 생성
            2. 선언적 환경 레코드 생성
        4. this 바인딩
        5. 외부 렉시컬 환경에 대한 참조 결정
- `let`, `const`로 선언한 변수는 블록 레벨 스코프를 따르기 때문에 함수뿐만 아니라 반복문, try-catch문 등의 코드 블록도 지역  스코프로 인정한다. 
``if``문 내에서 `let`으로 변수를 선언하면 `if`문의 코드 블록이 실행될 때 블록 레벨 스코프 생성을 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 생성해서 기존의 전역 렉시컬 환경을 교체, 이때 새롭게 생성된 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if문의 실행되기 이전의 전역 렉시컬 환경을 가리킴. `if`문 실행이 종료되면 `if`문이 실행되기 전의 렉시컬 환경으로 원복
