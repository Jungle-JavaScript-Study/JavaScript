

**8.1 블록문**

- 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.
- 자체 종결성을 가지고 있기 때문에 세미콜론을 붙이기 않는다.

**8.2 조건문**

주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다. 

조건식은 불리언 값으로 평가될 수 있는 **표현식**이다.

**8.2.1 if…else문**

- if의 조건식은 불리언 값으로 평가되어야 한다.
- 만약 불리언값이 아닌 값으로 평가되면 JS엔진에 의해  암묵적으로 불리언 값으로 강제 변환되어 실행할 코드를 결정한다.
- 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.

**8.2.2 switch 문**

- 상황을(case)을 의미하는 표형식을 지정하고 콜론으로 마친다.
- break없이 스위치 문을 작성할경우 
switch문을 탈출하지 않고 끝날때까지 모든 case문과 defailt문을 실행하는 **폴스루**가 발생할 수 있다.
- 조건이 많을 경우 if..else문 보다는 switch문을 사용하는 편이 좋다.

**8.3 반복문**

**8.3.1 for 문**

**8.3.2 while문**

**8.3.3 do…while 문**

**8.4 break 문**

코드 블록을 탈출하기 위해 사용된다 break이외에도 레이블문이 있는데

**레이블문**은 프로그램 실행 순서를 제어하는데 사용한다.

```jsx
let array1 = [1, 2, 3, 4];
let array2 = ['a', 'b', 'c', 'd'];

outerLoop: // 이것이 레이블입니다.
for (let i = 0; i < array1.length; i++) {
    console.log('Outer loop:', i);
    for (let j = 0; j < array2.length; j++) {
        console.log('Inner loop:', j);
        if (i === 2 && j === 2) {
            break outerLoop; // outerLoop 레이블을 사용하여 외부 반복문을 종료합니다.
        }
    }
}
```

**8.5 continue 문**

반복문의 코드 블록 실행을 현 지점에서 중단하고

반복문의 증감식으로 실행 흐름을 이동시킨다.

break 문처럼 반복문을 탈출하지 않는다.

**9.1 타입 변환이란?**

개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환 또는 타입캐스팅** 이라고 한다.

이와 반대로 개발자의 의도와는 상관없이 표현되는 방식을 **암묵적 타입변환 또는 타입 강제변환** 이라 한다.

자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적 타입 변환해 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.

**9.2 암묵적 타입 변환**

자바 스크립트 엔진은 표현식을 평가할 때, 개발자의 의도와는 상관없이 코드의 문맥을 고려해 **암묵적으로 데이터 타입을 강제 변환**할 때가 있다.

문자열 타입변환

```jsx
let value = 5 + "7"; // "57"
```

비교연산

```jsx
let result = "5" == 5; // true
```

불린연산

```jsx
let isTrue = !!5; // true
let isFalse = !!0; // false
```

산술연산

```jsx
let result = "5" - 2; // 3
```

**9.3 명시적 타입 변환**

개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다

숫자로 변환

```jsx
let str = "123";
let num = Number(str);  // 123
```

문자열로 변환

```jsx
let num = 123;
let str = String(num);  // "123"
```

불린으로 변환

```jsx
let truthyStr = Boolean("Hello"); // true
let falsyNum = Boolean(0); // false
```

**9.4 단축평가**

논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는것을 단축평가라고 한다.

즉, 평가 도중에 평가 결과가 확정된 경우 나머지 평과 과정을 생략하는것을 말한다.

객체가 가리키기를 기대하는 변수가 null또는 undefiend인 경우

객체의 프로퍼티를 참조하면 타입에러가 발생한다. 

이때, 단축 평가를 사용하면 에러를 발생시키지 않는다.

```jsx
let obj = null;

// 단축 평가를 사용하지 않는 경우
try {
    console.log(obj.property); // TypeError: Cannot read property 'property' of null
} catch (error) {
    console.error(error);
}

// 단축 평가를 사용하는 경우
console.log(obj && obj.property); // null, 에러가 발생하지 않음
```

이 방법 외에 체이닝 방법을 사용하면 더 간단하게 처리할 수 있다.

```jsx
console.log(obj?.property)
```

**10.1 객체란?**

자바스크립트를 구성하는 거의 “모든것”이 객체다.

원시타입은 단 하나의 값을 나타내지만 객체타입은 다양한 타입의 값을 하나의 단위로 구상한다.

원시타입 : 원시값은 변경이 불사능한 값

객체타입 : 변경 가능한 값

자바에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.(함수 일 경우 메서드라고 부름)

**10.2 객테 리터럴에 의한 객체 생성**

**10.3 프로퍼티**

객체는 프로퍼티의 집합이며 프로퍼티는 키와 값으로 구성된다.

```jsx
// 객체 생성
let car = {
    brand: 'Tesla',  // brand 프로퍼티
    model: 'Model 3', // model 프로퍼티
    price: 35000,  // price 프로퍼티
    start: function() {  // start 메서드 (메서드도 하나의 프로퍼티입니다)
        console.log('The car starts.');
    }
};

// 프로퍼티에 접근
console.log(car.brand);  // 'Tesla'
console.log(car['model']);  // 'Model 3'

// 메서드 실행
car.start();  // 'The car starts.'

// 프로퍼티 변경
car.price = 40000;
console.log(car.price);  // 40000

// 새로운 프로퍼티 추가
car.color = 'Red';
console.log(car.color);  // 'Red'

//프로퍼티 삭제
delete car.color;
```

**10.4 메서드**

프로퍼티 값이 함수일 경우 일반함수와 구분하기 위해서 메서드라고 한다.

**10.5 프로퍼티 접근**

**10.6 프로퍼티 값 갱신**

"얕은 복사(shallow copy)"와 "깊은 복사(deep copy)"는 객체를 복사하는 두 가지 주요 방법입니다. 객체에 대한 이해가 필요한데, 객체는 JavaScript에서 복합 데이터 유형을 나타내며, 여러 값을 속성으로 가질 수 있습니다.

**얕은 복사**:
얕은 복사는 객체의 최상위 수준의 속성들만 복사합니다. 원본 객체와 복사된 객체가 같은 메모리 위치에 있는 중첩된 객체를 공유하기 때문에, 한 객체에서 중첩된 객체를 변경하면 다른 객체에도 영향을 미칩니다.

```
let obj1 = { a: 1, b: { c: 2 } };
let shallowCopy = Object.assign({}, obj1);
shallowCopy.b.c = 3;
console.log(obj1.b.c); // 3 - 원본 객체도 변경되었습니다.

```

**깊은 복사**:
깊은 복사는 객체의 모든 수준의 속성들을 복사합니다. 이 경우 원본 객체와 복사된 객체는 완전히 독립적입니다. 하나의 객체에서 변경사항이 다른 객체에 영향을 미치지 않습니다. JavaScript에서 깊은 복사를 수행하려면 종종 `JSON.parse(JSON.stringify(obj))`와 같은 방법을 사용합니다.

```
let obj2 = { a: 1, b: { c: 2 } };
let deepCopy = JSON.parse(JSON.stringify(obj2));
deepCopy.b.c = 3;
console.log(obj2.b.c); // 2 - 원본 객체는 변경되지 않았습니다.

```

이러한 차이점 때문에 어떤 유형의 복사를 사용할지는 원하는 동작에 따라 결정해야 합니다. 중첩된 객체를 포함하는 객체를 복사해야 하고 복사본에서 변경사항이 원본에 영향을 미치지 않아야 하는 경우에는 깊은 복사를 사용해야 합니다. 그러나 이것은 비용이 많이 드는 작업이므로, 중첩된 객체가 없거나 복사본에서의 변경이 원본에 반영되어도 괜찮은 경우에는 얕은 복사를 사용할 수 있습니다.

**10.7 프로퍼티 동적 생성** 

**10.8 프로퍼티 삭제**

**10.9 ES6에서 추가된 객체 리터럴의 확장 가능**

**11.1 원시값**

원시 타입(Primitive type)은 JavaScript에서 가장 기본적인 데이터 타입입니다. 이에는 `Number`, `String`, `Boolean`, `null`, `undefined`, `Symbol`, `BigInt`가 포함됩니다.

원시값은 불변적입니다. 즉, 한 번 생성된 원시값은 수정, 변경, 혹은 변형할 수 없습니다. 예를 들어, 다음과 같은 문자열을 고려해봅시다:

```
let str = "hello";
str[0] = "H";
console.log(str); // "hello"

```

우리는 `str[0]`을 통해 첫 번째 문자를 'H'로 변경하려 했지만, 결과적으로 문자열은 변경되지 않았습니다. 왜냐하면 문자열은 원시값이며 불변하기 때문입니다.

**11.2 객체**

객체는 참조 타입입니다. 원시값과는 달리 객체는 변경이 가능합니다. 객체는 키-값 쌍을 저장하는 컨테이너로, 이 값들은 추가, 수정, 삭제가 가능합니다.

다음은 객체의 속성을 변경하는 예입니다:

```
let person = { name: "John" };
person.name = "Jane"; // 객체의 속성을 변경합니다.
console.log(person.name); // "Jane"

```

위의 예시에서 `person` 객체의 `name` 속성은 변경이 가능했습니다.

그러나 객체를 "변경 가능하다"고 표현할 때 주의해야 합니다. 객체 자체가 변경 가능한 것이지, 객체가 저장되는 메모리 주소는 불변입니다. 즉, 한 번 생성된 객체는 다른 메모리 공간에 저장된 다른 객체로 변경할 수 없습니다.

```
let obj1 = { value: 10 };
let obj2 = obj1;

obj1 = { value: 20 };
console.log(obj2.value); // 10

```

위의 예시에서 `obj1`에 새로운 객체를 할당해도 `obj2`는 원래의 객체를 참조하게 됩니다. 이는 `obj1`의 메모리 주소를 변경했지만, `obj2`가 참조하는 주소는 그대로 유지되었기 때문입니다. 이처럼 객체는 참조에 의해 접근되며, 이 참조는 객체의 메모리 주소를 가리킵니다.
