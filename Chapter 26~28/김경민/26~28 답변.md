## Ch 26~28 질문리스트에 대한 답변

- ES6 이전과 이후의 함수는 어떻게 달라졌나요 ?
  - ES6부터는 화살표 함수가 생겼고, 함수 매개변수에 기본값을 지정할 수 있게 되었으며, 개수가 가변적인 매개변수를 전달할 수 있게 되었고, 스프레드 연산자로 객체를 복제할 수 있게 되었습니다. 또한 블록 레벨에서 함수를 정의할 수 있게 되었습니다.
  - ES6 이전의 모든 함수는 callable이면서 constructor 였지만, ES6 이후에는 일반 함수는 constructor 이지만 메서드와 화살표 함수는 non-constructor 입니다.

  <details>
  <summary>꼬리질문</summary>

  - 어떤 문제가 생기기 때문에 함수의 종류를 구분하였나요 ?
    <br>
    - JavaScript의 ES6에서 함수의 종류를 구분한 것은 언어의 일관성과 특히 this 바인딩의 복잡성을 줄이기 위한 시도입니다.

ES6 이전에는 함수의 정의와 사용 방식에 따라 this 값이 동적으로 결정되었습니다. 이로 인해 다수의 개발자들이 예상하지 못한 동작과 버그를 겪게 되었습니다.
  </details><br>

- 자바스크립트의 배열은 일반적인 자료구조 배열과 다른데, 어떤 점이 다른가요 ?

  - 동적으로 크기 조절 가능.
  - 자료구조 배열은 밀집 배열, 자바스크립트 배열은 희소 배열.
  - 자바스크립트의 배열은 객체임. 따라서 여러 메서드와 속성, 여러 타입을 포함할 수 있음.
  - 전통적 배열은 연속적이기 때문에 인덱싱에 빠름. 자바스크립트에서는 해시 테이블을 사용하여 구현하기 때문에 삽입 삭제에 유리함.
    <details>
    <summary>꼬리질문</summary>

    - 그러면 일반적인 배열과 자바스크립트 배열의 장단점에 대해서 말해주세요.
      - 일반적인 배열 장점: 연속적이기 때문에 접근 및 변경이 빠름.
      - 일반적인 배열 단점: 동적인 크기 변경이 어려움. 하나의 데이터 타입만 저장 가능.

      - 자바스크립트 배열 장점: 동적 크기 변경 가능, 다양한 타입 원소 포함 가능. 내장 메서드와 속성을 통한 조작이 간편.
      - 자바스크립트 배열 단점: 인덱싱에서 전톡적인 배열보다 느리다.

    </details><br>

- 자바스크립트에서 배열을 생성하는 방법에 대해서 말해주세요.
  - 리터럴, Array 생성자, Array.of 메서드, Array.from 메서드, 스프레드 연산자 사용 등의 방법이 있습니다.<br><br>


- 자바스크립트에서 배열의 요소를 삭제하는 방법에 대해서 설명해주세요.
  - splice() 메서드, delete 연산자, pop() 메서드, shift() 메서드, length 속성 변경 등의 방법이 있습니다.<br><br>

- Array.prototype.sort 를 이용해 아래 코드를 정렬하면 어떤 결과가 나오나요 ?  
    왜 그런 결과가 나오나요 ?
    
    ```javascript
    const points = [40, 100, 1, 5, 2, 25, 10];
    
    points.sort();
    
    console.log(points); // ??
    ```

    - Array.prototype.sort() 메서드를 사용하여 배열을 정렬할 때, 배열의 요소들은 기본적으로 문자열로 변환되고, 그 문자열 값들을 기준으로 사전식 정렬이 이루어집니다.

      ```javascript
      // 결과
      [1, 10, 100, 2, 25, 40, 5]
      ```

    <details>
    <summary>꼬리질문</summary>

    - 자바스크립트의 sort는 어떤 정렬알고리즘을 사용하나요 ?

        - quicksort 알고리즘을 사용했었는데, quicksort 방식은 동일한 값의 요소가 중복일 때 초기 순서와 변경될 수 있는 불안정한 알고리즘이기 때문에, ES10 이후에는 timsort 알고리즘을 사용하도록 바뀌었습니다.

        <details>
        <summary>꼬리질문</summary>

        - 그러면 그 알고리즘에 대해서 설명해주세요.

          - 퀵 정렬은 분할 정복 방식의 알고리즘입니다.
            - 배열에서 피벗이라는 임의 요소를 선택하고 피벗을 기준으로 배열을 두 부분으로 분할합니다. 각 부분 배열에 대해 퀵 정렬을 재귀적으로 실행합니다.
            - 시간복잡도는 평균적인 경우 O(n log n), 최악의 경우 O(n^2)으로, 이미 배열이 정렬되어있거나 거의 정렬된 경우에는 비효율적입니다. 또한 동일한 값의 초기 순서가 유지되지 않을 수 있습니다.

          - 팀정렬 알고리즘은 병합 정렬과 삽입 정렬의 하이브리드 알고리즘입니다.
            - 배열을 작은 부분 배열(일반적으로 32개의 요소)로 나누고, 각 부분 배열을 삽입 정렬로 정렬한 다음, 정렬된 부분 배열들을 병합 정렬 방식으로 병합합니다.
            - 시간 복잡도는 평균적인 경우와 최악의 경우 모두 O(n log n)로 효율적입니다.
        </details>
    </details><br>

- Number메서드 중 Number.isFinite 와 Number.isNaN이 있는 것으로 아는데, 
빌트인 전역 함수 isFinite와 isNaN 함수와의 다른점이 무엇인가요 ?

  - Number.isFinite()와 Number.isNaN()는 숫자 타입의 값만 검사하므로 더 엄격하게 동작합니다. 빌트인 전역 함수인 isFinite()와 isNaN()은 타입을 숫자로 강제 변환하여 검사하기 때문에 예상치 못한 결과를 반환할 수 있습니다.
