# 16장 프로퍼티 어트리뷰트

### Q1. 데이터 프로퍼티의 프로퍼티 어트리뷰트 4개

A. [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]이 있습니다.

<br>


### Q2. 프로퍼티가 생성될 때 데이터 프로퍼티의 각 프로퍼티 어트리뷰트는 어떤 값으로 초기화되나요?

A. [[Value]]의 값은 프로퍼티 값으로 초기화 되며, [[Writable]], [[Enumerable]], [[Configurable]]의 값은 true로 초기화 됩니다. 이것은 프로퍼티를 동적 추가해도 마찬가지 입니다.

<br>


### Q3. 접근자 프로퍼티의 프로퍼티 어트리뷰트 4개

A. [[Get]], [[Set]], [[Enumerable]], [[Configurable]]이 있습니다.

<br>


### Q4. JavaScript에서 객체의 변경을 방지하는 메서드에는 어떤 게 있나요?

A. Object.preventExtensions, Object.seal, Object.freeze가 있습니다.
preventExtensions는 프로퍼티 추가만 금지하고, seal은 여기에 추가로 삭제와 재정의 금지(읽기 쓰기만 가능), freeze로 동결된 객체는 읽기만 가능합니다.

<br>

### Q4-1. 위 메서드를 사용해 변경을 방지한 객체의 중첩 객체는 변경이 가능한가요?

A. 앞에 언급한 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못합니다.
읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 합니다.(deepFreeze)

<br>

# 17장 생성자 함수에 의한 객체 생성

### Q5. 생성자 함수는 어떤 함수인가요?

A. 생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말합니다.

<br>

### Q6. 생성자 함수에 의해 생성된 객체를 부르는 용어는 무엇인가요?

A. 인스턴스라고 합니다!

<br>

### Q7. 객체를 생성할 때, 객체 리터럴을 사용하지 않고 생성자 함수로 생성하는 것이 더 유리한 상황은 언제인가요?

A. 프로퍼티 구조가 동일한 객체 여러 개를 생성할 때 보다 간편하게 생성할 수 있습니다.

<br>

### Q8. 생성자 함수를 정의하는 방법을 설명해주세요.

A. 
1. 생성자 함수를 만들기 위해 함수를 선언합니다. 이 때,일반 함수와 구분하기 위해 관례적으로 파스칼 케이스로 작성합니다.
2. 생성자 함수의 내용을 작성합니다. 여기서 객체의 속성을 초기화 하고, 메서드를 정의하는 등의 작업을 수행합니다. this 키워드를 사용해서 생성될 객체를 참조합니다.
3. new 키워드와 함께 생성자 함수를 호출하고 필요한 인수를 전달합니다.

<br>

### Q9. 생성자 함수를 new 연산자 없이 호출하면 어떻게 동작하나요?

A. 일반 함수로 동작합니다.

<br>

### Q9-1. JavaScript의 빌트인 생성자 함수인 String, Number, Boolean 생성자 함수를 new 연산자 없이 호출하면 어떻게 동작하나요?

A. 문자열, 숫자, 불리언 값을 반환합니다. 이를 통해 데이터 타입을 변환하기도 합니다.

<br>

### Q10. 생성자 함수로서 호출할 수 있는 함수와 그럴 수 없는 함수는 어떻게 구분되나요?

함수 정의 방식에 따라 구분합니다. <br>
함수 선언문, 함수 표현식, 클래스는 생성자 함수로서 호출될 수 있는 constructor이고, <br>
ES6의 메서드 축약 표현으로 작성된 메서드, 화살표 함수는 non-constructor로 생성자 함수로 호출할 수 없습니다.

<br/>

### Q11. 생성자 함수 내부의 this에 값이 최초로 바인딩 되는 시점은 언제이고, 어떤 값이 바인딩 되나요?

A. 런타임 이전에 실행되며, 암묵적으로 생성된 빈 객체(인스턴스)가 this에 바인딩 됩니다.

<br>

### Q12. 생성자 함수 내부의 this는 무엇을 가리키나요?

A. 생성자 함수가 생성할 인스턴스를 가리킵니다 !

<br>

### Q12-1. 생성자 함수를 new 연산자 없이 호출했을 때 함수 내부의 this는 무엇을 가리키나요?

A. 일반 함수로 호출됐을 때는 전역 객체, 메서드로 호출됐을 때는 메서드를 호출한 객체(마침표 앞 객체)를 가리킵니다.

<br>

### Q13. 생성자 함수가 생성자 함수로서 호출되었는지 확인하는 방법을 설명해주세요.

A. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있습니다. <br>
new 연산자와 함께 생성장 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킵니다. <br>
new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined입니다.

<br>

# 18장 함수와 일급 객체

### Q14. 일급 객체가 되는 조건 4개

A.
1. 무명의 리터럴로 생성이 가능(즉 런타임에 생성이 가능)해야 합니다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있어야 합니다.
3. 함수의 매개변수에 전달할 수 있어야 하며,
4. 함수의 반환값으로 사용할 수 있어야 합니다.

<br>

### Q14-1. 일급 객체는 어떤 객체를 의미하나요?

A. 컴퓨터 프로그래밍 언어 디자인에서, 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킵니다.

<br>

### Q15. 함수 호출 시 매개변수의 개수보다 인수를 초과하여 전달한 경우 초과된 인수를 어떻게 확인할 수 있나요?

A. 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관됩니다. 브라우저 콘솔에서 확인할 수 있습니다.

<br>

### Q15-1. 위 질문의 답이 되는 기능의 활용 방안을 설명해주세요.

A. 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용합니다.

<br>

### Q16. arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티는 각각 무엇의 개수를 가리키나요?

A. arguments 객체의 length 프로퍼티는 인수의 개수를 가리키며, 함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킵니다.

<br>

### Q17. prototype 프로퍼티가 없는 함수는 어떤 함수인가요?

A. prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티입니다.
생성자 함수로 호출할 수 없는 non-constructor 함수는 prototype 프로퍼티가 없습니다.

<br>

### Q17-1. prototype 프로퍼티는 무엇을 가리키나요?

A. 함수가 생성자 함수로 호출될 때 생성할 인스턴스의 프로토타입 객체를 가리킵니다.

<br>

# 20장 strict mode

### Q18. JavaScript에서 strict mode를 적용하는 방법을 설명해주세요.

A. 전역의 선두 또는 함수 몸체 선두에 'use strict';를 추가하면 됩니다.

<br>

### Q18-1. strict mode가 발생시키는 에러 4개

A. 선언하지 않은 변수를 참조하면 ReferenceError를, <br> 
delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError를, <br>
중복된 매개변수 이름을 사용하면 SyntaxError를, <br>
with 문을 사용하면 SyntaxError를 발생시킵니다.

<br>

### Q18-2. strict mode 적용에 의한 변화 2개

A. 
1. 일반 함수로 함수를 호출하면 this에 undefined가 바인딩 됩니다. 생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문입니다. 이 때 에러는 발생하지 않습니다.
2. 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않습니다.

<br>

### Q19. 프로젝트에서 사용한 라이브러리 혹은 프레임워크에서 strict mode를 설정하는 방법을 설명해주세요.
(React or Next.js 중 사용한 것 기준으로 설명해주세요.)

React: <br>
StrictMode 태그를 사용하여 감싼 영역에 strict mode가 적용됩니다.
<br>

Next.js: <br>
버전 13.4부터 default로 Strict Mode가 활성화됩니다. <br>
next.config.js에서 reactStrictMode의 값을 변경해 strict mode 활성화 여부를 설정할 수 있습니다.
<br>

### Q19-1. react에서 strict mode를 사용하면 (개발 환경에서) 어떤 동작이 활성화되나요?

A.
React 16.3 이상에서는 StrictMode를 활성화하면 다음과 같은 동작들이 활성화됩니다:

1. 불필요한 렌더링 검출: 컴포넌트가 불필요하게 여러 번 렌더링되는 것을 감지하여 애플리케이션의 성능 향상에 도움을 줍니다.
2. 비동기 안전성 검사: 트리 내의 모든 컴포넌트에 대해 렌더를 두 번 호출하여 예기치 않은 방식으로 동작하지 않는지 확인합니다.
3. 레거시 API와 메서드의 사용 검출: 이제는 권장되지 않는 생명주기 메서드와 deprecated된 API를 사용하는 것을 경고로 알려줍니다.
4. 잘못된 Ref 사용 검출: 문자열 ref나 함수 ref를 사용하는 것을 경고로 알려줍니다.
5. useEffect 정리의 추가 실행: useEffect 훅의 정리(clean-up) 함수를 추가로 한 번 더 실행하여, 정리가 누락되어 발생하는 버그를 찾는 데 도움을 줍니다.

이러한 기능은 개발 모드에서만 작동하며, 프로덕션 환경에는 영향을 미치지 않습니다.
