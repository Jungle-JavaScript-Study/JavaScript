**Q1. 데이터 프로퍼티의 프로퍼티 어트리뷰트 4개**

A. 데이터 프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티

1. value (값을 반환함)
2. Write (쓰기 권한 / 변경 가능 여부)
3. Eumerable (읽기 권한 여부)
4. Configurable(재정의 가능 여부)

**Q2. 프로퍼티가 생성될 때 데이터 프로퍼티의 각 프로퍼티 어트리뷰트는 어떤 값으로 초기화되나요?**

A.  valu를 제외한 모든 프로퍼티는 true로 초기화 됩니다. 동적 처리도 마찬가지다. 단, 생략하면 false로 나온다.

**Q3. 접근자 프로퍼티의 프로퍼티 어트리뷰트 4개**

A. 1. get 2. set 3.eumerable 4.configurable

**Q4. JavaScript에서 객체의 변경을 방지하는 메서드에는 어떤 게 있나요?**

A. 객체 확장을 금지시키는 메서드, 객체를 밀봉시키는 메서드, 객체를 ㄷ오결시키는 메서드가 있습니다

1. 첫번째 메서드의 경우 확장이 금지되어 프로퍼티 추가가 금지 됩니다.
2. 읽기와 쓰기 권한만 가능합니다.
3. 읽기만 가능합니다.

**Q4-1. 위 메서드를 사용해 변경을 방지한 객체의 중첩 객체는 변경이 가능한가요?**

A. 네 가능합니다. 얕은 변경 방지 직속으로 중첩객체는 변경이 가능합니다.

**Q5. 생성자 함수는 어떤 함수인가요?**

A. 생성자 함수는 객체를 생성하고 초기화하는 특별한 종류의 함수입니다.

**Q6. 생성자 함수에 의해 생성된 객체를 부르는 용어는 무엇인가요?**

A. 인스턴스라고 합니다.

**Q7. 객체를 생성할 때, 객체 리터럴을 사용하지 않고 생성자 함수로 생성하는 것이 더 유리한 상황은 언제인가요?**

A. 같은 구조를 가진 객체를 여러번 생성해야할때 생성자 함수를 사용할 경우 코드 가독성 측면에서 유리합니다.

**Q8. 생성자 함수를 정의하는 방법을 설명해주세요.**

A. 일반 함수를 생성하고 new연산자와 함께 호출하여 정의할 수 있습니다.

**Q9. 생성자 함수를 new 연산자 없이 호출하면 어떻게 동작하나요?**

A. 일반 함수로 동작하게 됩니다.

**Q9-1. JavaScript의 빌트인 생성자 함수인 String, Number, Boolean 생성자 함수를 new 연산자 없이 호출하면 어떻게 동작하나요?**

A. 각 데이터 타입의 원시값으로 저장됩니다.

**Q10. 생성자 함수로서 호출할 수 있는 함수와 그럴 수 없는 함수는 어떻게 구분되나요?
A.** constructor의 여부에 따라 구분됩니다. 이는 함수의 구현방식으로 나눠집니다.

**Q11. 생성자 함수 내부의 this에 값이 최초로 바인딩 되는 시점은 언제이고, 어떤 값이 바인딩 되나요?**

A. 런타임 이전에 암묵적으로 생선된 빈 객체가 this에 바인딩 됩니다.

**Q12. 생성자 함수 내부의 this는 무엇을 가리키나요?**

A. 해당 생성자가 생성할 인스턴스 코드블럭을 가르킵니다.

**Q12-1. 생성자 함수를 new 연산자 없이 호출했을 때 함수 내부의 this는 무엇을 가리키나요?**

A. 전역(window)를 가르킵니다.

**Q13. 생성자 함수가 생성자 함수로서 호출되었는지 확인하는 방법을 설명해주세요.**

A. ES6에서는 new.target을 지원하여 생성자 함수로 호출되었는지 알 수 있습니다.

해당 메서드를 지원하지 않는 버전이라면 스코프 세이브 생성자 패턴을 사용할 수 있습니다.

**Q14. 일급 객체가 되는 조건 4개**

1. 무명의 리터럴로 생성이 가능합니다.
2. 변수나 자료구조에 저장할 수 있습니다.
3. 함수의 매개변수에 전달할 수 있습니다.
4. 함수의 반환값으로 사용할 수 있습니다.

**Q14-1. 일급 객체는 어떤 객체를 의미하나요? (남들과 같은 차별없이 다 지원할 수 있는 의미이다.)**

A. 함수의 매개변수에 전달할 수 있고 함수의 반환값으로 사용할 수 있는 것을 의미합니다.

**Q15. 함수 호출 시 매개변수의 개수보다 인수를 초과하여 전달한 경우 초과된 인수를 어떻게 확인할 수 있나요?**

A. 모든 프로퍼티 어트리뷰트를 확인할 수 있는 OwnPropertyDescriptors 메서드로 확인할 수 있습니다.

아규먼트로 확인 가능

**Q15-1. 위 질문의 답이 되는 기능의 활용 방안을 설명해주세요.**

A.  인수의 값이 명확하지 않을 때 활용할 수 있습니다.

arguments 객체는

매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 활용할 수 있습니다.

명확하지 않은 것이 접근성이 좋지 않기깨문 Rest파라미터를 이용하자 

**Q16. arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티는 각각 무엇의 개수를 가리키나요?**

A. 객체의 경우 실제 전달된 인자를 가르키고 함수의 경우 매게변수의 개수를 가르킵니다.

```jsx
function exampleFunc(a, b, c) {
    console.log(arguments.length);  // 실제 전달된 인수의 개수
    console.log(exampleFunc.length);  // 함수 선언에서 지정된 매개변수의 개수
}

exampleFunc(1, 2);  // 출력: 2, 3
```

**Q17. prototype 프로퍼티가 없는 함수는 어떤 함수인가요?**

A. non-constuctor의 경우 프로퍼티가 없습니다.

**Q17-1. prototype 프로퍼티는 무엇을 가리키나요?**

A. 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가르킵니다.

**Q18. JavaScript에서 strict mode를 적용하는 방법을 설명해주세요.**

esLint를 사용하거나 strict mod를 코드블럭에 선언하여 사용할 수 있습니다.

전역의 선두 또는 함수 몸체의 선두에 `'use strict';`를 추가합니다.

**Q18-1. strict mode가 발생시키는 에러 4개**

1. 함수의 중복선언
2. 매개변수 중복
3. 매개변수 삭제
4. whit문의 사용

- **암묵전역 생성**이랑 **호이스팅**이 다른 점

**Q18-2. strict mode 적용에 의한 변화 2개**

1. 일반 함수의 this
2. 아규먼트 객체

**Q19. 프로젝트에서 사용한 라이브러리 혹은 프레임워크에서 strict mode를 설정하는 방법을 설명해주세요.**

```jsx
import React from 'react';

function ExampleApplication() {
    return (
        <React.StrictMode>
            <div>
                {/* 여기에 컴포넌트들을 넣으면 됩니다. */}
            </div>
        </React.StrictMode>
    );
}

export default ExampleApplication;
```

**Q19-1. react에서 strict mode를 사용하면 (개발 환경에서) 어떤 동작이 활성화되나요?**

A.레거시 컴포넌트의 라이프 사이클 메서드와, 새로운 라이프 사이클 메서드 사용을 경고하고, 예기치 않은 부작용과 레거시 컨텍스트 API 사용 등에 대한 경고를 제공합니다.
