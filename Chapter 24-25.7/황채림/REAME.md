## 24. 클로저

- 자스는 **렉시컬 스코프**를 따르는 프로그래밍 언어 → 함수 호출이 아니라 **정의 위치**에 따라 상위 스코프가 결정되고 함수 객체가 사라질때까지 유지
= 렉시컬 환경의 `outerLexicalEnvironmentReference`에 저장되는 참조값 
= 함수 객체의 내부 슬롯 `[[Environment]]`에 저장된 참조값 
= 현재 실행 중(정의 되는 시점)인 실행 컨텍스트의 렉시컬 환경의 참조값
- 클로저: 외부 함수보다 중첩 함수가 **오래 유지**되는 경우 이미 죽은 **외부 함수의 식별자를 참조**할 수 있음, 이때의 중첩 함수 → 모든 함수는 어디서 호출하든 상위 스코프를 기억하기 때문에 상위 스코프의 식별자를 참조할 수 있음 (외부 함수가 종료되면 실행 컨텍스트는 스택에서 사라지지만 내부 함수에서 참조하는 렉시컬 환경은 사라지지 않음)
    - 외부 함수보다 중첩 함수가 오래 유지되지만 상위 스코프의 식별자를 참조하지 않으면 상위 스코프를 기억하지 않음 → 클로저가 아님
    - 중첩 함수가 외부 함수 밖으로 반환되지 않음 → 중첩 함수의 생명 주기가 외부 함수보다 짧아 클로저가 아님
- 자유 변수: 클로저에 의해 참조되는 상위 스코프의 변수
    - 클로저가 참조하는 상위 스코프에서도 자유 변수가 아니면 기억하지 않음
- 클로저는 state를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용
    
    ```jsx
    const increase = (function () {
    	let num = 0;
    
    	return function () {
    		return ++num;
    	};
    }());
    ```
    
    ```jsx
    const counter = (function () {
    	let num = 0;
    
    	return {
    		increase() {
    			return ++num;
    		},
    		decrease() {
    			return n > 0 ? --num : 0;
    		}
    	};
    }());
    ```
    
- 캡슐화: 프로퍼티+메서드를 하나로 묶는 것 → 객체의 프로퍼티나 메서드를 감추는 정보 은닉의 목적으로 사용하기도 함
- 정보 은닉의 효과: 구현의 일부를 감춰서 객체 상태가 변경되는 것을 방지, 객체 간의 결합도를 낮춤
    - 자스에서는 `priviate`을 지원하지 않아 정보 은닉 불가능
- `let`이나 `const`를 사용하는 반복문 내부에 함수를 정의하면 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성해서 당시의 상태를 스냅숏으로 저장함

## 25. 클래스

- 클래스는 일급 객체 → 무명 리터럴로 생성 가능(런타임에 생성), 변수에 저장 가능, 매개변수에 전달 가능, 함수 리턴값으로 사용 가능
- 클래스는 함수라서 클래스 선언문으로 정의하면 런타이 이전에 먼저 평가돼서 함수 객체 생성, 이 함수가 `constructor`이기 때문에 프로토타입도 동시에 생성
- 뭐든지 선언문 형태로 선언하면 호이스팅됨, `class`도 호이스팅되지만 `let`, `const`처럼 TDZ에 빠짐
- `new` 키워드 없이 클래스 호출하면 TypeError
- 기명 함수/클래스 표현식에서 사용한 함수/클래스 이름은 외부 코드에서는 접근 불가능, 할당된 식별자로 접근해야 함
- 클래스는 생성자함수와 거의 유사한 프로토타입 기반 객체 생성 메커니즘
- 클래스 몸체에는 `constructor`, 프로토타입 메서드, 정적 메서드를 정의할 수 있음
    1. `constructor`: 인스턴스 생성&초기화하는 특수 메서드
        - 클래스 정의가 평가되면 `constructor`와 같은 동작을 하는 함수 객체가 생성됨
        - 클래스 내에 한개만 존재하거나 생략
        - `new` 연산자랑 클래스가 호출되면 암묵적으로 인스턴스를 리턴함, 원시값이 아닌 객체를 리턴하면 해당 객체 리턴 → `constructor` 내에는 `return`문 없어야 함
    2. 프로토타입 메서드: 클래스 몸체에서 정의하면 기본적으로 프로토타입 메서드
    3. 정적 메서드: `static` 키워드 붙은 메서드는 정적 메서드가 되어 인스턴스 생성 없이 호출할 수 있음 → 클래스에 바인딩된 메서드이기 때문에 클래스로만 호출할 수 있고 인스턴스로는 호출 불가, 인스턴스의 프로토타입 체인에 없음
    - 메서드 내부의 this는 메서드를 호출한 객체에 바인딩되므로 프로토타입 메서드 내의 `this`는 인스턴스를 가리키고 정적 메서드 내부의 `this`는 클래스를 가리킴
    - 클래스/생성자 함수를 네임스페이스로 사용해 정적 메서드를 모아놓으면 전역적으로 사용할 유틸리티 함수를 전역 함수로 만들지 않고 구조화하기 좋음 (ex. `Math.max()`)
- 클래스에서 메서드를 정의할때는 메서드 축약 표현을 사용
- 클래스에서 정의한 메서드는 암묵적으로 strict mode로 실행되고 해제할 수 없음
- `constructor` 내부의 `this`에 프로퍼티를 추가하면 인스턴스의 프로퍼티가 됨 (`public`)
- 클래스의 접근자 프로퍼티는 프로토타입의 프로퍼티가 됨
- 이제 자스도 클래스 필드 사용 가능(함수 몸체에 `this`없이 선언하기), 그러나 굳이?
- 클래스 필드명 앞에 `#` 붙이면 `private` 필드(ECMA 제안)
