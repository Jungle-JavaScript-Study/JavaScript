# 24장 클로저

### Q1. 클로저란?

<details>
<summary>정답</summary>

- 함수와 그 함수가 선언된 렉시컬 환경과의 조합입니다.
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있는데, 이러한 중첩 함수를 클로저라고 부릅니다.
- 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적입니다.

</details>

<br/>

### Q1-1. 클로저에 의해 참조되는 상위 스코프의 변수를 부르는 용어는 무엇인가요?

<details>
<summary>정답</summary>

<br/>
자유 변수 free variable

</details>

<br/>

### Q2. 렉시컬 스코프란?

<details>
<summary>정답</summary>

<br/>
JS 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는데, 이것을 렉시컬 스코프(정적 스코프)라고 합니다.

</details>

<br/>

### Q3. 함수는 상위 스코프를 어디에, 언제까지 기억하나요?

<details>
<summary>정답</summary>

<br/>
함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억합니다.

</details>

<br/>

### Q4. 클로저가 발생하는 원리를 설명해주세요.

<details>
<summary>정답</summary>

<br/>
함수는 자신의 상위 스코프를 기억합니다.
<br/>
중첩 함수인 경우, 내부 함수가 외부 함수를 참조하고 있으면
<br/>
외부 함수가 종료되면서 실행 컨텍스트 스택에서 제거되더라도 외부 함수의 렉시컬 환경까지 소멸하지는 않습니다.
<br/>
이는 누군가가 참조하고 있는 메모리 공간은 가비지 컬렉션의 대상이 되지 않기 때문입니다.
<br/>
따라서 외부 함수보다 더 오래 생존한 중첩 함수는 외부 함수의 생존 여부와 상관 없이 
<br/>
정의된 위치에서 결정된 상위 스코프를 기억하고, 상위 스코프 내부의 식별자를 참조할 수 있게 됩니다.

</details>

<br/>

### Q5. 클로저를 어떤 경우에 활용하면 좋을까요?

<details>
<summary>정답</summary>

<br/>
클로저는 상태를 안전하게 변경하고 유지하기 위해 사용합니다.
<br/>
상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해서 사용합니다.

</details>

<br/>

### Q6. encapsulation과 information hiding을 설명해주세요.

<details>
<summary>정답</summary>

<br/>
캡슐화는 객체의 상태를 나타내는 프로퍼티와 메서드를 하나로 묶는 것을 말합니다.
<br/>
캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 합니다.
<br/>
정보 은닉은 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도(coupling)을 낮추는 효과가 있습니다.

</details>

<br/>

### Q6-1. coupling을 설명해주세요.

(책에 없어용 추가로 찾아본 내용입니다)

<details>
<summary>정답</summary>

- 결합도(coupling)는 한 컴포넌트, 모듈 또는 클래스가 다른 컴포넌트, 모듈 또는 클래스에 얼마나 강하게 의존하는지를 나타냅니다. 이는 소프트웨어의 여러 부분 사이의 상호 의존성을 측정하는 데 사용되며, 이 결합도는 가능한 한 낮추는 것이 바람직합니다.
- 결합도가 높은 경우, 한 부분에서의 변경이 다른 부분에도 영향을 미칠 가능성이 높아집니다. 이는 유지보수를 어렵게 만들고 버그를 발생시킬 수 있습니다. 반대로, 결합도가 낮은 시스템은 각 컴포넌트, 모듈 또는 클래스가 독립적으로 동작할 수 있으며, 따라서 테스트와 유지보수가 더 쉽습니다.
- 결합도를 낮추는 한 가지 방법은 객체 지향 프로그래밍의 원칙 중 하나인 의존성 역전 원칙(Dependency Inversion Principle)을 적용하는 것입니다. 이 원칙은 상위 수준의 모듈이 하위 수준의 모듈에 직접적으로 의존하는 대신, 추상화된 인터페이스를 통해 의존성을 관리하도록 권장합니다.

</details>

<br/>

### Q7. 데이터 은닉을 위한 방법 중 클로저를 활용하는 것과 private을 활용하는 것 중 무엇이 더 좋은 방법인가요?

(책에 없어용 추가로 찾아본 내용입니다)

<details>
<summary>정답</summary>

<br/>

- 클로저를 활용하는 방법과 private 필드를 활용하는 방법 모두 자바스크립트에서 데이터 은닉을 위한 방법입니다. 그러나 어떤 방법이 더 낫다고 일괄적으로 말하기는 어렵고, 상황에 따라 적합한 방법을 선택하는 것이 중요합니다.
- 클로저를 활용하는 경우의 장점:
    - 클로저는 자바스크립트가 발전하면서 이전 버전부터 계속해서 사용되어 왔으므로, 예전 버전의 자바스크립트 환경에서도 코드가 작동한다는 장점이 있습니다. 따라서 호환성이 중요한 상황에서는 클로저를 사용하는 것이 더 나을 수 있습니다.
    - 클로저는 상태를 유지할 수 있으며, 함수 팩토리나 메모이제이션 등의 특정 패턴을 구현하는데 유용합니다.
- private 필드를 활용하는 경우의 장점:
    - private 필드는 자바스크립트 클래스에서 직관적으로 사용할 수 있습니다. 이는 코드의 가독성을 높여줄 수 있습니다.
    - private 필드는 '진정한' private을 제공하므로, 데이터를 보다 안전하게 은닉할 수 있습니다. 클로저를 통한 데이터 은닉은 여전히 외부로 노출될 수 있는 반면, private 필드는 완전히 은닉되므로 외부에서 접근할 수 없습니다.
    - 최신 자바스크립트 환경에서는 private 필드를 지원하므로, modern 자바스크립트 문법을 사용하려는 경우 private 필드를 사용하는 것이 더 나을 수 있습니다.

</details>

<br/>

# 25장 클래스

### Q1. 클래스와 생성자 함수의 차이 5개

<details>
<summary>힌트</summary>

- new 연산자
- 상속 키워드
- 호이스팅
- strict mode
- Enumerable

</details>

<details>
<summary>정답</summary>

- new 연산자 없이 호출하면 클래스는 에러가 발생하고, 생성자 함수는 일반 함수로서 호출됩니다.
- 클래스는 상속을 지원하는 extends와 super 키워드를 제공하지만 생성자 함수는 지원하지 않습니다.
- 클래스는 호이스팅이 발생하지 않는 것처럼 동작합니다. 생성자 함수는 함수 선언문으로 정의된 경우 함수 호이스팅이, 함수 표현식으로 정의한 경우 변수 호이스팅이 발생합니다.
- 클래스 내의 코드는 strict mode가 지정되어 실행되며 해제할 수 없습니다. 생성자 함수는 strict mode가 지정되어 있지 않습니다.
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 열거되지 않습니다. 생성자 함수의 인스턴스에 메서드를 추가한 경우에는 열거가 가능합니다.

</details>

<br/>


### Q2. 클래스 몸체에서 정의할 수 있는 메서드 중 constructor는 어떤 역할을 하나요?

<details>
<summary>정답</summary>

인스턴스를 생성하고 초기화하는 특수한 메서드입니다.

</details>

<br/>


### Q2-1. constructor를 생략할 수 있나요?

<details>
<summary>정답</summary>

넹 constructor를 생략하면 빈 constructor가 암묵적으로 정의되고, 빈 객체를 생성합니다.

</details>

<br/>


### Q3. 클래스 메서드를 생성하는 방법을 설명해주세요.

<details>
<summary>정답</summary>

메서드 앞에 static 키워드를 붙이면 정적 메서드(클래스 메서드)가 됩니다.

</details>

<br/>

### Q4. 인스턴스로 정적 메서드를 호출하면 메서드 내부의 this는 어떤 객체를 가리키나요?

<details>
<summary>정답</summary>

정적 메서드는 인스턴스로 호출할 수 없습니다.ㅎㅎ
<br/>
정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인 상에 존재하지 않기 때문입니다.

</details>

<br/>

### Q5. 정적 메서드와 프로토타입 메서드의 차이 3개

<details>
<summary>힌트</summary>

- 프로토타입 체인
- 호출 방식
- 인스턴스 프로퍼티 참조 가능 여부

</details>

<details>
<summary>정답</summary>

- 메서드가 속해 있는 프로토타입 체인이 다릅니다.
- 호출 방식이 다릅니다. (정적 메서드는 클래스로, 프로토타입 메서드는 인스턴스로 호출합니다.)
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있습니다.

</details>

<br/>

### Q6. 정적 메서드를 클래스에 모아 놓았을 때 얻을 수 있는 이점을 설명해주세요.

<details>
<summary>정답</summary>

- 이름 충돌 가능성을 줄여주고 관련 함수들을 구조화할 수 있습니다.
- 따라서 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지 않고 메서드로 구조화할 때 정적 메서드를 사용하면 유용합니다.

<br/>

### Q6-1. 유틸리티 함수는 어떤 함수를 의미하나요?

(책에 없는 내용)

<details>
<summary>정답</summary>

- 흔히 사용되는 작업을 수행하는 작은 보조 함수를 의미합니다.
- 유틸리티 함수의 예시로는 날짜 포매팅, 숫자 포매팅, 문자열 처리 (대문자 변환, 소문자 변환, 공백 제거 등), 배열이나 객체에 대한 일반적인 연산 (필터링, 정렬, 탐색 등) 등이 있습니다.

</details>

<br/>

### Q7. 클래스의 인스턴스 생성 과정을 순서대로 설명해주세요.

<details>
<summary>정답</summary>

- 인스턴스 생성과 this 바인딩
    - new 연산자와 함께 클래스를 호출하면 constructor 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체가 생성되고, 빈 객체(, 즉 인스턴스)가 this에 바인딩됩니다.
- 인스턴스 초기화
    - constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화합니다.
- 인스턴스 반환
    - 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됩니다.

</details>

<br/>

### Q8. 클래스가 생성한 인스턴스의 프로토타입에는 어떤 값이 설정되나요?

<details>
<summary>정답</summary>

- 클래스의 prototype 프로퍼티가 가리키는 객체가 설정됩니다.

</details>

<br/>

### Q9. 클래스의 인스턴스 프로퍼티를 정의하는 방법을 설명해주세요.

<details>
<summary>정답</summary>

- 인스턴스 프로퍼티는 constructor 내부에서 this에 추가합니다.

</details>

<br/>

### Q9-1. 클래스의 몸체에서 인스턴스 프로퍼티를 정의할 수 있나요?

<details>
<summary>정답</summary>

- 최신 브라우저(Chrome 72 이상) 또는 최신 Node.js(버전 12 이상)에서는 클래스 몸체에 클래스 필드를 정의할 수 있습니다.

</details>

<br/>

### Q10. 클래스의 접근자 프로퍼티를 정의하는 방법을 설명해주세요.

<details>
<summary>정답</summary>

- 접근자 프로퍼티는 getter 함수와 setter 함수로 구성되어 있습니다.
- getter는 메서드 이름 앞에 get 키워드를, setter는 set 키워드를 붙여서 정의합니다.

</details>

<br/>

### Q11. (최신 브라우저에서 지원하는) 클래스 내부에서만 참조하는 필드를 정의하는 방법을 설명해주세요.

<details>
<summary>정답</summary>

- 필드를 정의할 때 선두에 #을 붙이면 클래스 외부에서 접근할 수 없게 됩니다. 참조할 때도 #을 붙여서 사용합니다.

</details>

<br/>

### Q12. (최신 브라우저에서 지원하는) 정적 필드를 정의하는 방법을 설명해주세요.

<details>
<summary>정답</summary>

- 필드 앞에 static 키워드를 붙입니다.

</details>

<br/>
<br/>
<br/>
